this.onerror = function(e) {
  console.error(e);
}


function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}
function getTotalMemory() {
  return TOTAL_MEMORY;
}
function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      ++len;
    } else if (u <= 0x7FF) {
      len += 2;
    } else if (u <= 0xFFFF) {
      len += 3;
    } else if (u <= 0x1FFFFF) {
      len += 4;
    } else if (u <= 0x3FFFFFF) {
      len += 5;
    } else {
      len += 6;
    }
  }
  return len;
}
function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x1FFFFF) {
      if (outIdx + 3 >= endIdx) break;
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x3FFFFFF) {
      if (outIdx + 4 >= endIdx) break;
      outU8Array[outIdx++] = 0xF8 | (u >> 24);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 5 >= endIdx) break;
      outU8Array[outIdx++] = 0xFC | (u >> 30);
      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}
function _emscripten_is_main_runtime_thread() {
    return __pthread_is_main_runtime_thread|0; // Semantically the same as testing "!ENVIRONMENT_IS_PTHREAD" outside the asm.js scope
}
function _emscripten_futex_wait(addr, val, timeout) {
      if (addr <= 0 || addr > HEAP8.length || addr&3 != 0) return -22;
  //    dump('futex_wait addr:' + addr + ' by thread: ' + _pthread_self() + (ENVIRONMENT_IS_PTHREAD?'(pthread)':'') + '\n');
      if (ENVIRONMENT_IS_WORKER) {
        var ret = Atomics.wait(HEAP32, addr >> 2, val, timeout);
  //    dump('futex_wait done by thread: ' + _pthread_self() + (ENVIRONMENT_IS_PTHREAD?'(pthread)':'') + '\n');
        if (ret === 'timed-out') return -110;
        if (ret === 'not-equal') return -11;
        if (ret === 'ok') return 0;
        throw 'Atomics.wait returned an unexpected value ' + ret;
      } else {
        // Atomics.wait is not available in the main browser thread, so simulate it via busy spinning.
        var loadedVal = Atomics.load(HEAP32, addr >> 2);
        if (val != loadedVal) return -11;
  
        var tNow = performance.now();
        var tEnd = tNow + timeout;
  
  
        // Register globally which address the main thread is simulating to be waiting on. When zero, main thread is not waiting on anything,
        // and on nonzero, the contents of address pointed by __main_thread_futex_wait_address tell which address the main thread is simulating its wait on.
        Atomics.store(HEAP32, __main_thread_futex_wait_address >> 2, addr);
        var ourWaitAddress = addr; // We may recursively re-enter this function while processing queued calls, in which case we'll do a spurious wakeup of the older wait operation.
        while (addr == ourWaitAddress) {
          tNow = performance.now();
          if (tNow > tEnd) {
            return -110;
          }
          _emscripten_main_thread_process_queued_calls(); // We are performing a blocking loop here, so must pump any pthreads if they want to perform operations that are proxied.
          addr = Atomics.load(HEAP32, __main_thread_futex_wait_address >> 2); // Look for a worker thread waking us up.
        }
        return 0;
      }
    }
function _malloc($0) {
 $0 = $0|0;
 var $$$0172$i = 0, $$$0173$i = 0, $$$4230$i = 0, $$$4236$i = 0, $$$4329$i = 0, $$$i = 0, $$0$i = 0, $$0$i$i = 0, $$0$i$i$i = 0, $$0$i17$i = 0, $$0172$lcssa$i = 0, $$01724$i = 0, $$0173$lcssa$i = 0, $$01733$i = 0, $$0193 = 0, $$0195 = 0, $$0201$i$i = 0, $$0202$i$i = 0, $$0206$i$i = 0, $$0207$i$i = 0;
 var $$024359$i = 0, $$0260$i$i = 0, $$0261$i$i = 0, $$0262$i$i = 0, $$0268$i$i = 0, $$0269$i$i = 0, $$0320$i = 0, $$0322$i = 0, $$0323$i = 0, $$0325$i = 0, $$0331$i = 0, $$0336$i = 0, $$0337$$i = 0, $$0337$i = 0, $$0339$i = 0, $$0340$i = 0, $$0345$i = 0, $$1 = 0, $$1176$i = 0, $$1178$i = 0;
 var $$124458$i = 0, $$1264$i$i = 0, $$1266$i$i = 0, $$1321$i = 0, $$1326$i = 0, $$1341$i = 0, $$1347$i = 0, $$1351$i = 0, $$2 = 0, $$2234243136$i = 0, $$2247$ph$i = 0, $$2253$ph$i = 0, $$2333$i = 0, $$3$i = 0, $$3$i$i = 0, $$3$i196 = 0, $$3229$i = 0, $$3235$i = 0, $$3328$i = 0, $$3349$i = 0;
 var $$4$lcssa$i = 0, $$4$ph$i = 0, $$4230$i = 0, $$4236$i = 0, $$4329$lcssa$i = 0, $$43298$i = 0, $$4335$$4$i = 0, $$4335$ph$i = 0, $$43357$i = 0, $$49$i = 0, $$7$i = 0, $$7239$i = 0, $$pre = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i18$i = 0, $$pre$i203 = 0, $$pre$phi$i$iZ2D = 0, $$pre$phi$i19$iZ2D = 0, $$pre$phi$i204Z2D = 0;
 var $$pre$phi$iZ2D = 0, $$pre$phiZ2D = 0, $$sink1$i = 0, $$sink1$i$i = 0, $$sink12$i = 0, $$sink2$i = 0, $$sink2$i198 = 0, $$sink3$i = 0, $1 = 0, $10 = 0, $100 = 0, $1000 = 0, $1001 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0;
 var $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0;
 var $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0;
 var $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0;
 var $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0;
 var $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0;
 var $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0;
 var $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0;
 var $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0;
 var $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0;
 var $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0;
 var $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0;
 var $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0;
 var $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0;
 var $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0;
 var $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0;
 var $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0;
 var $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0;
 var $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0;
 var $432 = 0, $433 = 0, $434 = 0, $435 = 0, $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0;
 var $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0;
 var $469 = 0, $47 = 0, $470 = 0, $471 = 0, $472 = 0, $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0;
 var $487 = 0, $488 = 0, $489 = 0, $49 = 0, $490 = 0, $491 = 0, $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0, $503 = 0;
 var $504 = 0, $505 = 0, $506 = 0, $507 = 0, $508 = 0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0;
 var $522 = 0, $523 = 0, $524 = 0, $525 = 0, $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0, $539 = 0, $54 = 0;
 var $540 = 0, $541 = 0, $542 = 0, $543 = 0, $544 = 0, $545 = 0, $546 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0;
 var $559 = 0, $56 = 0, $560 = 0, $561 = 0, $562 = 0, $563 = 0, $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0, $569 = 0, $57 = 0, $570 = 0, $571 = 0, $572 = 0, $573 = 0, $574 = 0, $575 = 0, $576 = 0;
 var $577 = 0, $578 = 0, $579 = 0, $58 = 0, $580 = 0, $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0, $593 = 0, $594 = 0;
 var $595 = 0, $596 = 0, $597 = 0, $598 = 0, $599 = 0, $6 = 0, $60 = 0, $600 = 0, $601 = 0, $602 = 0, $603 = 0, $604 = 0, $605 = 0, $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0, $610 = 0, $611 = 0;
 var $612 = 0, $613 = 0, $614 = 0, $615 = 0, $616 = 0, $617 = 0, $618 = 0, $619 = 0, $62 = 0, $620 = 0, $621 = 0, $622 = 0, $623 = 0, $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0;
 var $630 = 0, $631 = 0, $632 = 0, $633 = 0, $634 = 0, $635 = 0, $636 = 0, $637 = 0, $638 = 0, $639 = 0, $64 = 0, $640 = 0, $641 = 0, $642 = 0, $643 = 0, $644 = 0, $645 = 0, $646 = 0, $647 = 0, $648 = 0;
 var $649 = 0, $65 = 0, $650 = 0, $651 = 0, $652 = 0, $653 = 0, $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0, $660 = 0, $661 = 0, $662 = 0, $663 = 0, $664 = 0, $665 = 0, $666 = 0;
 var $667 = 0, $668 = 0, $669 = 0, $67 = 0, $670 = 0, $671 = 0, $672 = 0, $673 = 0, $674 = 0, $675 = 0, $676 = 0, $677 = 0, $678 = 0, $679 = 0, $68 = 0, $680 = 0, $681 = 0, $682 = 0, $683 = 0, $684 = 0;
 var $685 = 0, $686 = 0, $687 = 0, $688 = 0, $689 = 0, $69 = 0, $690 = 0, $691 = 0, $692 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0, $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0, $700 = 0, $701 = 0;
 var $702 = 0, $703 = 0, $704 = 0, $705 = 0, $706 = 0, $707 = 0, $708 = 0, $709 = 0, $71 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $72 = 0;
 var $720 = 0, $721 = 0, $722 = 0, $723 = 0, $724 = 0, $725 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0, $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0, $737 = 0, $738 = 0;
 var $739 = 0, $74 = 0, $740 = 0, $741 = 0, $742 = 0, $743 = 0, $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0, $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0, $755 = 0, $756 = 0;
 var $757 = 0, $758 = 0, $759 = 0, $76 = 0, $760 = 0, $761 = 0, $762 = 0, $763 = 0, $764 = 0, $765 = 0, $766 = 0, $767 = 0, $768 = 0, $769 = 0, $77 = 0, $770 = 0, $771 = 0, $772 = 0, $773 = 0, $774 = 0;
 var $775 = 0, $776 = 0, $777 = 0, $778 = 0, $779 = 0, $78 = 0, $780 = 0, $781 = 0, $782 = 0, $783 = 0, $784 = 0, $785 = 0, $786 = 0, $787 = 0, $788 = 0, $789 = 0, $79 = 0, $790 = 0, $791 = 0, $792 = 0;
 var $793 = 0, $794 = 0, $795 = 0, $796 = 0, $797 = 0, $798 = 0, $799 = 0, $8 = 0, $80 = 0, $800 = 0, $801 = 0, $802 = 0, $803 = 0, $804 = 0, $805 = 0, $806 = 0, $807 = 0, $808 = 0, $809 = 0, $81 = 0;
 var $810 = 0, $811 = 0, $812 = 0, $813 = 0, $814 = 0, $815 = 0, $816 = 0, $817 = 0, $818 = 0, $819 = 0, $82 = 0, $820 = 0, $821 = 0, $822 = 0, $823 = 0, $824 = 0, $825 = 0, $826 = 0, $827 = 0, $828 = 0;
 var $829 = 0, $83 = 0, $830 = 0, $831 = 0, $832 = 0, $833 = 0, $834 = 0, $835 = 0, $836 = 0, $837 = 0, $838 = 0, $839 = 0, $84 = 0, $840 = 0, $841 = 0, $842 = 0, $843 = 0, $844 = 0, $845 = 0, $846 = 0;
 var $847 = 0, $848 = 0, $849 = 0, $85 = 0, $850 = 0, $851 = 0, $852 = 0, $853 = 0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0, $859 = 0, $86 = 0, $860 = 0, $861 = 0, $862 = 0, $863 = 0, $864 = 0;
 var $865 = 0, $866 = 0, $867 = 0, $868 = 0, $869 = 0, $87 = 0, $870 = 0, $871 = 0, $872 = 0, $873 = 0, $874 = 0, $875 = 0, $876 = 0, $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0, $881 = 0, $882 = 0;
 var $883 = 0, $884 = 0, $885 = 0, $886 = 0, $887 = 0, $888 = 0, $889 = 0, $89 = 0, $890 = 0, $891 = 0, $892 = 0, $893 = 0, $894 = 0, $895 = 0, $896 = 0, $897 = 0, $898 = 0, $899 = 0, $9 = 0, $90 = 0;
 var $900 = 0, $901 = 0, $902 = 0, $903 = 0, $904 = 0, $905 = 0, $906 = 0, $907 = 0, $908 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0, $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0, $917 = 0, $918 = 0;
 var $919 = 0, $92 = 0, $920 = 0, $921 = 0, $922 = 0, $923 = 0, $924 = 0, $925 = 0, $926 = 0, $927 = 0, $928 = 0, $929 = 0, $93 = 0, $930 = 0, $931 = 0, $932 = 0, $933 = 0, $934 = 0, $935 = 0, $936 = 0;
 var $937 = 0, $938 = 0, $939 = 0, $94 = 0, $940 = 0, $941 = 0, $942 = 0, $943 = 0, $944 = 0, $945 = 0, $946 = 0, $947 = 0, $948 = 0, $949 = 0, $95 = 0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0;
 var $955 = 0, $956 = 0, $957 = 0, $958 = 0, $959 = 0, $96 = 0, $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0, $966 = 0, $967 = 0, $968 = 0, $969 = 0, $97 = 0, $970 = 0, $971 = 0, $972 = 0;
 var $973 = 0, $974 = 0, $975 = 0, $976 = 0, $977 = 0, $978 = 0, $979 = 0, $98 = 0, $980 = 0, $981 = 0, $982 = 0, $983 = 0, $984 = 0, $985 = 0, $986 = 0, $987 = 0, $988 = 0, $989 = 0, $99 = 0, $990 = 0;
 var $991 = 0, $992 = 0, $993 = 0, $994 = 0, $995 = 0, $996 = 0, $997 = 0, $998 = 0, $999 = 0, $cond$i = 0, $cond$i$i = 0, $cond$i202 = 0, $not$3$i = 0, $or$cond$i = 0, $or$cond$i206 = 0, $or$cond1$i = 0, $or$cond1$i205 = 0, $or$cond10$i = 0, $or$cond11$i = 0, $or$cond12$i = 0;
 var $or$cond2$i = 0, $or$cond42$i = 0, $or$cond5$i = 0, $or$cond7$i = 0, $or$cond9$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $1 = sp + 4|0;
 $2 = sp;
 $3 = HEAP32[33986]|0;
 $4 = ($3|0)==(0);
 if ($4) {
  (___pthread_mutex_lock(135968)|0);
  $5 = HEAP32[33986]|0;
  $6 = ($5|0)==(0);
  if ($6) {
   HEAP32[(135952)>>2] = 4096;
   HEAP32[(135948)>>2] = 4096;
   HEAP32[(135956)>>2] = -1;
   HEAP32[(135960)>>2] = -1;
   HEAP32[(135964)>>2] = 2;
   HEAP32[(136440)>>2] = 2;
   $7 = (_pthread_mutexattr_init($1)|0);
   $8 = ($7|0)==(0);
   if ($8) {
    $9 = (_pthread_mutex_init((136444),$1)|0);
    $10 = ($9|0)==(0);
    if ($10) {
    }
   }
   $11 = $2;
   $12 = $11 & -16;
   $13 = $12 ^ 1431655768;
   Atomics_store(HEAP32,33986,$13)|0;
  }
  (___pthread_mutex_unlock(135968)|0);
 }
 $14 = HEAP32[(136440)>>2]|0;
 $15 = $14 & 2;
 $16 = ($15|0)==(0);
 if (!($16)) {
  $17 = (___pthread_mutex_lock((136444))|0);
  $18 = ($17|0)==(0);
  if (!($18)) {
   $$1 = 0;
   STACKTOP = sp;return ($$1|0);
  }
 }
 $19 = ($0>>>0)<(245);
 do {
  if ($19) {
   $20 = ($0>>>0)<(11);
   $21 = (($0) + 11)|0;
   $22 = $21 & -8;
   $23 = $20 ? 16 : $22;
   $24 = $23 >>> 3;
   $25 = HEAP32[33999]|0;
   $26 = $25 >>> $24;
   $27 = $26 & 3;
   $28 = ($27|0)==(0);
   if (!($28)) {
    $29 = $26 & 1;
    $30 = $29 ^ 1;
    $31 = (($30) + ($24))|0;
    $32 = $31 << 1;
    $33 = (136036 + ($32<<2)|0);
    $34 = ((($33)) + 8|0);
    $35 = HEAP32[$34>>2]|0;
    $36 = ((($35)) + 8|0);
    $37 = HEAP32[$36>>2]|0;
    $38 = ($37|0)==($33|0);
    if ($38) {
     $39 = 1 << $31;
     $40 = $39 ^ -1;
     $41 = $25 & $40;
     HEAP32[33999] = $41;
    } else {
     $42 = ((($37)) + 12|0);
     HEAP32[$42>>2] = $33;
     HEAP32[$34>>2] = $37;
    }
    $43 = $31 << 3;
    $44 = $43 | 3;
    $45 = ((($35)) + 4|0);
    HEAP32[$45>>2] = $44;
    $46 = (($35) + ($43)|0);
    $47 = ((($46)) + 4|0);
    $48 = HEAP32[$47>>2]|0;
    $49 = $48 | 1;
    HEAP32[$47>>2] = $49;
    $$2 = $36;
    break;
   }
   $50 = HEAP32[(136004)>>2]|0;
   $51 = ($23>>>0)>($50>>>0);
   if ($51) {
    $52 = ($26|0)==(0);
    if (!($52)) {
     $53 = $26 << $24;
     $54 = 2 << $24;
     $55 = (0 - ($54))|0;
     $56 = $54 | $55;
     $57 = $53 & $56;
     $58 = (0 - ($57))|0;
     $59 = $57 & $58;
     $60 = (($59) + -1)|0;
     $61 = $60 >>> 12;
     $62 = $61 & 16;
     $63 = $60 >>> $62;
     $64 = $63 >>> 5;
     $65 = $64 & 8;
     $66 = $65 | $62;
     $67 = $63 >>> $65;
     $68 = $67 >>> 2;
     $69 = $68 & 4;
     $70 = $66 | $69;
     $71 = $67 >>> $69;
     $72 = $71 >>> 1;
     $73 = $72 & 2;
     $74 = $70 | $73;
     $75 = $71 >>> $73;
     $76 = $75 >>> 1;
     $77 = $76 & 1;
     $78 = $74 | $77;
     $79 = $75 >>> $77;
     $80 = (($78) + ($79))|0;
     $81 = $80 << 1;
     $82 = (136036 + ($81<<2)|0);
     $83 = ((($82)) + 8|0);
     $84 = HEAP32[$83>>2]|0;
     $85 = ((($84)) + 8|0);
     $86 = HEAP32[$85>>2]|0;
     $87 = ($86|0)==($82|0);
     if ($87) {
      $88 = 1 << $80;
      $89 = $88 ^ -1;
      $90 = $25 & $89;
      HEAP32[33999] = $90;
      $107 = $90;
     } else {
      $91 = ((($86)) + 12|0);
      HEAP32[$91>>2] = $82;
      HEAP32[$83>>2] = $86;
      $107 = $25;
     }
     $92 = $80 << 3;
     $93 = (($92) - ($23))|0;
     $94 = $23 | 3;
     $95 = ((($84)) + 4|0);
     HEAP32[$95>>2] = $94;
     $96 = (($84) + ($23)|0);
     $97 = $93 | 1;
     $98 = ((($96)) + 4|0);
     HEAP32[$98>>2] = $97;
     $99 = (($84) + ($92)|0);
     HEAP32[$99>>2] = $93;
     $100 = ($50|0)==(0);
     if (!($100)) {
      $101 = HEAP32[(136016)>>2]|0;
      $102 = $50 >>> 3;
      $103 = $102 << 1;
      $104 = (136036 + ($103<<2)|0);
      $105 = 1 << $102;
      $106 = $107 & $105;
      $108 = ($106|0)==(0);
      if ($108) {
       $109 = $107 | $105;
       HEAP32[33999] = $109;
       $$pre = ((($104)) + 8|0);
       $$0195 = $104;$$pre$phiZ2D = $$pre;
      } else {
       $110 = ((($104)) + 8|0);
       $111 = HEAP32[$110>>2]|0;
       $$0195 = $111;$$pre$phiZ2D = $110;
      }
      HEAP32[$$pre$phiZ2D>>2] = $101;
      $112 = ((($$0195)) + 12|0);
      HEAP32[$112>>2] = $101;
      $113 = ((($101)) + 8|0);
      HEAP32[$113>>2] = $$0195;
      $114 = ((($101)) + 12|0);
      HEAP32[$114>>2] = $104;
     }
     HEAP32[(136004)>>2] = $93;
     HEAP32[(136016)>>2] = $96;
     $$2 = $85;
     break;
    }
    $115 = HEAP32[(136000)>>2]|0;
    $116 = ($115|0)==(0);
    if ($116) {
     $$0193 = $23;
     label = 108;
    } else {
     $117 = (0 - ($115))|0;
     $118 = $115 & $117;
     $119 = (($118) + -1)|0;
     $120 = $119 >>> 12;
     $121 = $120 & 16;
     $122 = $119 >>> $121;
     $123 = $122 >>> 5;
     $124 = $123 & 8;
     $125 = $124 | $121;
     $126 = $122 >>> $124;
     $127 = $126 >>> 2;
     $128 = $127 & 4;
     $129 = $125 | $128;
     $130 = $126 >>> $128;
     $131 = $130 >>> 1;
     $132 = $131 & 2;
     $133 = $129 | $132;
     $134 = $130 >>> $132;
     $135 = $134 >>> 1;
     $136 = $135 & 1;
     $137 = $133 | $136;
     $138 = $134 >>> $136;
     $139 = (($137) + ($138))|0;
     $140 = (136300 + ($139<<2)|0);
     $141 = HEAP32[$140>>2]|0;
     $142 = ((($141)) + 4|0);
     $143 = HEAP32[$142>>2]|0;
     $144 = $143 & -8;
     $145 = (($144) - ($23))|0;
     $146 = ((($141)) + 16|0);
     $147 = HEAP32[$146>>2]|0;
     $148 = ($147|0)==(0|0);
     $$sink12$i = $148&1;
     $149 = (((($141)) + 16|0) + ($$sink12$i<<2)|0);
     $150 = HEAP32[$149>>2]|0;
     $151 = ($150|0)==(0|0);
     if ($151) {
      $$0172$lcssa$i = $141;$$0173$lcssa$i = $145;
     } else {
      $$01724$i = $141;$$01733$i = $145;$153 = $150;
      while(1) {
       $152 = ((($153)) + 4|0);
       $154 = HEAP32[$152>>2]|0;
       $155 = $154 & -8;
       $156 = (($155) - ($23))|0;
       $157 = ($156>>>0)<($$01733$i>>>0);
       $$$0173$i = $157 ? $156 : $$01733$i;
       $$$0172$i = $157 ? $153 : $$01724$i;
       $158 = ((($153)) + 16|0);
       $159 = HEAP32[$158>>2]|0;
       $160 = ($159|0)==(0|0);
       $$sink1$i = $160&1;
       $161 = (((($153)) + 16|0) + ($$sink1$i<<2)|0);
       $162 = HEAP32[$161>>2]|0;
       $163 = ($162|0)==(0|0);
       if ($163) {
        $$0172$lcssa$i = $$$0172$i;$$0173$lcssa$i = $$$0173$i;
        break;
       } else {
        $$01724$i = $$$0172$i;$$01733$i = $$$0173$i;$153 = $162;
       }
      }
     }
     $164 = (($$0172$lcssa$i) + ($23)|0);
     $165 = ($164>>>0)>($$0172$lcssa$i>>>0);
     if ($165) {
      $166 = ((($$0172$lcssa$i)) + 24|0);
      $167 = HEAP32[$166>>2]|0;
      $168 = ((($$0172$lcssa$i)) + 12|0);
      $169 = HEAP32[$168>>2]|0;
      $170 = ($169|0)==($$0172$lcssa$i|0);
      do {
       if ($170) {
        $175 = ((($$0172$lcssa$i)) + 20|0);
        $176 = HEAP32[$175>>2]|0;
        $177 = ($176|0)==(0|0);
        if ($177) {
         $178 = ((($$0172$lcssa$i)) + 16|0);
         $179 = HEAP32[$178>>2]|0;
         $180 = ($179|0)==(0|0);
         if ($180) {
          $$3$i = 0;
          break;
         } else {
          $$1176$i = $179;$$1178$i = $178;
         }
        } else {
         $$1176$i = $176;$$1178$i = $175;
        }
        while(1) {
         $181 = ((($$1176$i)) + 20|0);
         $182 = HEAP32[$181>>2]|0;
         $183 = ($182|0)==(0|0);
         if (!($183)) {
          $$1176$i = $182;$$1178$i = $181;
          continue;
         }
         $184 = ((($$1176$i)) + 16|0);
         $185 = HEAP32[$184>>2]|0;
         $186 = ($185|0)==(0|0);
         if ($186) {
          break;
         } else {
          $$1176$i = $185;$$1178$i = $184;
         }
        }
        HEAP32[$$1178$i>>2] = 0;
        $$3$i = $$1176$i;
       } else {
        $171 = ((($$0172$lcssa$i)) + 8|0);
        $172 = HEAP32[$171>>2]|0;
        $173 = ((($172)) + 12|0);
        HEAP32[$173>>2] = $169;
        $174 = ((($169)) + 8|0);
        HEAP32[$174>>2] = $172;
        $$3$i = $169;
       }
      } while(0);
      $187 = ($167|0)==(0|0);
      do {
       if (!($187)) {
        $188 = ((($$0172$lcssa$i)) + 28|0);
        $189 = HEAP32[$188>>2]|0;
        $190 = (136300 + ($189<<2)|0);
        $191 = HEAP32[$190>>2]|0;
        $192 = ($$0172$lcssa$i|0)==($191|0);
        if ($192) {
         HEAP32[$190>>2] = $$3$i;
         $cond$i = ($$3$i|0)==(0|0);
         if ($cond$i) {
          $193 = 1 << $189;
          $194 = $193 ^ -1;
          $195 = $115 & $194;
          HEAP32[(136000)>>2] = $195;
          break;
         }
        } else {
         $196 = ((($167)) + 16|0);
         $197 = HEAP32[$196>>2]|0;
         $198 = ($197|0)!=($$0172$lcssa$i|0);
         $$sink2$i = $198&1;
         $199 = (((($167)) + 16|0) + ($$sink2$i<<2)|0);
         HEAP32[$199>>2] = $$3$i;
         $200 = ($$3$i|0)==(0|0);
         if ($200) {
          break;
         }
        }
        $201 = ((($$3$i)) + 24|0);
        HEAP32[$201>>2] = $167;
        $202 = ((($$0172$lcssa$i)) + 16|0);
        $203 = HEAP32[$202>>2]|0;
        $204 = ($203|0)==(0|0);
        if (!($204)) {
         $205 = ((($$3$i)) + 16|0);
         HEAP32[$205>>2] = $203;
         $206 = ((($203)) + 24|0);
         HEAP32[$206>>2] = $$3$i;
        }
        $207 = ((($$0172$lcssa$i)) + 20|0);
        $208 = HEAP32[$207>>2]|0;
        $209 = ($208|0)==(0|0);
        if (!($209)) {
         $210 = ((($$3$i)) + 20|0);
         HEAP32[$210>>2] = $208;
         $211 = ((($208)) + 24|0);
         HEAP32[$211>>2] = $$3$i;
        }
       }
      } while(0);
      $212 = ($$0173$lcssa$i>>>0)<(16);
      if ($212) {
       $213 = (($$0173$lcssa$i) + ($23))|0;
       $214 = $213 | 3;
       $215 = ((($$0172$lcssa$i)) + 4|0);
       HEAP32[$215>>2] = $214;
       $216 = (($$0172$lcssa$i) + ($213)|0);
       $217 = ((($216)) + 4|0);
       $218 = HEAP32[$217>>2]|0;
       $219 = $218 | 1;
       HEAP32[$217>>2] = $219;
      } else {
       $220 = $23 | 3;
       $221 = ((($$0172$lcssa$i)) + 4|0);
       HEAP32[$221>>2] = $220;
       $222 = $$0173$lcssa$i | 1;
       $223 = ((($164)) + 4|0);
       HEAP32[$223>>2] = $222;
       $224 = (($164) + ($$0173$lcssa$i)|0);
       HEAP32[$224>>2] = $$0173$lcssa$i;
       $225 = ($50|0)==(0);
       if (!($225)) {
        $226 = HEAP32[(136016)>>2]|0;
        $227 = $50 >>> 3;
        $228 = $227 << 1;
        $229 = (136036 + ($228<<2)|0);
        $230 = 1 << $227;
        $231 = $25 & $230;
        $232 = ($231|0)==(0);
        if ($232) {
         $233 = $25 | $230;
         HEAP32[33999] = $233;
         $$pre$i = ((($229)) + 8|0);
         $$0$i = $229;$$pre$phi$iZ2D = $$pre$i;
        } else {
         $234 = ((($229)) + 8|0);
         $235 = HEAP32[$234>>2]|0;
         $$0$i = $235;$$pre$phi$iZ2D = $234;
        }
        HEAP32[$$pre$phi$iZ2D>>2] = $226;
        $236 = ((($$0$i)) + 12|0);
        HEAP32[$236>>2] = $226;
        $237 = ((($226)) + 8|0);
        HEAP32[$237>>2] = $$0$i;
        $238 = ((($226)) + 12|0);
        HEAP32[$238>>2] = $229;
       }
       HEAP32[(136004)>>2] = $$0173$lcssa$i;
       HEAP32[(136016)>>2] = $164;
      }
      $239 = ((($$0172$lcssa$i)) + 8|0);
      $$2 = $239;
     } else {
      $$0193 = $23;
      label = 108;
     }
    }
   } else {
    $$0193 = $23;
    label = 108;
   }
  } else {
   $240 = ($0>>>0)>(4294967231);
   if ($240) {
    $$0193 = -1;
    label = 108;
   } else {
    $241 = (($0) + 11)|0;
    $242 = $241 & -8;
    $243 = HEAP32[(136000)>>2]|0;
    $244 = ($243|0)==(0);
    if ($244) {
     $$0193 = $242;
     label = 108;
    } else {
     $245 = (0 - ($242))|0;
     $246 = $241 >>> 8;
     $247 = ($246|0)==(0);
     if ($247) {
      $$0336$i = 0;
     } else {
      $248 = ($242>>>0)>(16777215);
      if ($248) {
       $$0336$i = 31;
      } else {
       $249 = (($246) + 1048320)|0;
       $250 = $249 >>> 16;
       $251 = $250 & 8;
       $252 = $246 << $251;
       $253 = (($252) + 520192)|0;
       $254 = $253 >>> 16;
       $255 = $254 & 4;
       $256 = $255 | $251;
       $257 = $252 << $255;
       $258 = (($257) + 245760)|0;
       $259 = $258 >>> 16;
       $260 = $259 & 2;
       $261 = $256 | $260;
       $262 = (14 - ($261))|0;
       $263 = $257 << $260;
       $264 = $263 >>> 15;
       $265 = (($262) + ($264))|0;
       $266 = $265 << 1;
       $267 = (($265) + 7)|0;
       $268 = $242 >>> $267;
       $269 = $268 & 1;
       $270 = $269 | $266;
       $$0336$i = $270;
      }
     }
     $271 = (136300 + ($$0336$i<<2)|0);
     $272 = HEAP32[$271>>2]|0;
     $273 = ($272|0)==(0|0);
     L85: do {
      if ($273) {
       $$2333$i = 0;$$3$i196 = 0;$$3328$i = $245;
       label = 66;
      } else {
       $274 = ($$0336$i|0)==(31);
       $275 = $$0336$i >>> 1;
       $276 = (25 - ($275))|0;
       $277 = $274 ? 0 : $276;
       $278 = $242 << $277;
       $$0320$i = 0;$$0325$i = $245;$$0331$i = $272;$$0337$i = $278;$$0340$i = 0;
       while(1) {
        $279 = ((($$0331$i)) + 4|0);
        $280 = HEAP32[$279>>2]|0;
        $281 = $280 & -8;
        $282 = (($281) - ($242))|0;
        $283 = ($282>>>0)<($$0325$i>>>0);
        if ($283) {
         $284 = ($282|0)==(0);
         if ($284) {
          $$43298$i = 0;$$43357$i = $$0331$i;$$49$i = $$0331$i;
          label = 70;
          break L85;
         } else {
          $$1321$i = $$0331$i;$$1326$i = $282;
         }
        } else {
         $$1321$i = $$0320$i;$$1326$i = $$0325$i;
        }
        $285 = ((($$0331$i)) + 20|0);
        $286 = HEAP32[$285>>2]|0;
        $287 = $$0337$i >>> 31;
        $288 = (((($$0331$i)) + 16|0) + ($287<<2)|0);
        $289 = HEAP32[$288>>2]|0;
        $290 = ($286|0)==(0|0);
        $291 = ($286|0)==($289|0);
        $or$cond1$i = $290 | $291;
        $$1341$i = $or$cond1$i ? $$0340$i : $286;
        $292 = ($289|0)==(0|0);
        $not$3$i = $292 ^ 1;
        $293 = $not$3$i&1;
        $$0337$$i = $$0337$i << $293;
        if ($292) {
         $$2333$i = $$1341$i;$$3$i196 = $$1321$i;$$3328$i = $$1326$i;
         label = 66;
         break;
        } else {
         $$0320$i = $$1321$i;$$0325$i = $$1326$i;$$0331$i = $289;$$0337$i = $$0337$$i;$$0340$i = $$1341$i;
        }
       }
      }
     } while(0);
     if ((label|0) == 66) {
      $294 = ($$2333$i|0)==(0|0);
      $295 = ($$3$i196|0)==(0|0);
      $or$cond$i = $294 & $295;
      if ($or$cond$i) {
       $296 = 2 << $$0336$i;
       $297 = (0 - ($296))|0;
       $298 = $296 | $297;
       $299 = $243 & $298;
       $300 = ($299|0)==(0);
       if ($300) {
        $$0193 = $242;
        label = 108;
        break;
       }
       $301 = (0 - ($299))|0;
       $302 = $299 & $301;
       $303 = (($302) + -1)|0;
       $304 = $303 >>> 12;
       $305 = $304 & 16;
       $306 = $303 >>> $305;
       $307 = $306 >>> 5;
       $308 = $307 & 8;
       $309 = $308 | $305;
       $310 = $306 >>> $308;
       $311 = $310 >>> 2;
       $312 = $311 & 4;
       $313 = $309 | $312;
       $314 = $310 >>> $312;
       $315 = $314 >>> 1;
       $316 = $315 & 2;
       $317 = $313 | $316;
       $318 = $314 >>> $316;
       $319 = $318 >>> 1;
       $320 = $319 & 1;
       $321 = $317 | $320;
       $322 = $318 >>> $320;
       $323 = (($321) + ($322))|0;
       $324 = (136300 + ($323<<2)|0);
       $325 = HEAP32[$324>>2]|0;
       $$4$ph$i = 0;$$4335$ph$i = $325;
      } else {
       $$4$ph$i = $$3$i196;$$4335$ph$i = $$2333$i;
      }
      $326 = ($$4335$ph$i|0)==(0|0);
      if ($326) {
       $$4$lcssa$i = $$4$ph$i;$$4329$lcssa$i = $$3328$i;
      } else {
       $$43298$i = $$3328$i;$$43357$i = $$4335$ph$i;$$49$i = $$4$ph$i;
       label = 70;
      }
     }
     if ((label|0) == 70) {
      while(1) {
       label = 0;
       $327 = ((($$43357$i)) + 4|0);
       $328 = HEAP32[$327>>2]|0;
       $329 = $328 & -8;
       $330 = (($329) - ($242))|0;
       $331 = ($330>>>0)<($$43298$i>>>0);
       $$$4329$i = $331 ? $330 : $$43298$i;
       $$4335$$4$i = $331 ? $$43357$i : $$49$i;
       $332 = ((($$43357$i)) + 16|0);
       $333 = HEAP32[$332>>2]|0;
       $334 = ($333|0)==(0|0);
       $$sink2$i198 = $334&1;
       $335 = (((($$43357$i)) + 16|0) + ($$sink2$i198<<2)|0);
       $336 = HEAP32[$335>>2]|0;
       $337 = ($336|0)==(0|0);
       if ($337) {
        $$4$lcssa$i = $$4335$$4$i;$$4329$lcssa$i = $$$4329$i;
        break;
       } else {
        $$43298$i = $$$4329$i;$$43357$i = $336;$$49$i = $$4335$$4$i;
        label = 70;
       }
      }
     }
     $338 = ($$4$lcssa$i|0)==(0|0);
     if ($338) {
      $$0193 = $242;
      label = 108;
     } else {
      $339 = HEAP32[(136004)>>2]|0;
      $340 = (($339) - ($242))|0;
      $341 = ($$4329$lcssa$i>>>0)<($340>>>0);
      if ($341) {
       $342 = (($$4$lcssa$i) + ($242)|0);
       $343 = ($342>>>0)>($$4$lcssa$i>>>0);
       if ($343) {
        $344 = ((($$4$lcssa$i)) + 24|0);
        $345 = HEAP32[$344>>2]|0;
        $346 = ((($$4$lcssa$i)) + 12|0);
        $347 = HEAP32[$346>>2]|0;
        $348 = ($347|0)==($$4$lcssa$i|0);
        do {
         if ($348) {
          $353 = ((($$4$lcssa$i)) + 20|0);
          $354 = HEAP32[$353>>2]|0;
          $355 = ($354|0)==(0|0);
          if ($355) {
           $356 = ((($$4$lcssa$i)) + 16|0);
           $357 = HEAP32[$356>>2]|0;
           $358 = ($357|0)==(0|0);
           if ($358) {
            $$3349$i = 0;
            break;
           } else {
            $$1347$i = $357;$$1351$i = $356;
           }
          } else {
           $$1347$i = $354;$$1351$i = $353;
          }
          while(1) {
           $359 = ((($$1347$i)) + 20|0);
           $360 = HEAP32[$359>>2]|0;
           $361 = ($360|0)==(0|0);
           if (!($361)) {
            $$1347$i = $360;$$1351$i = $359;
            continue;
           }
           $362 = ((($$1347$i)) + 16|0);
           $363 = HEAP32[$362>>2]|0;
           $364 = ($363|0)==(0|0);
           if ($364) {
            break;
           } else {
            $$1347$i = $363;$$1351$i = $362;
           }
          }
          HEAP32[$$1351$i>>2] = 0;
          $$3349$i = $$1347$i;
         } else {
          $349 = ((($$4$lcssa$i)) + 8|0);
          $350 = HEAP32[$349>>2]|0;
          $351 = ((($350)) + 12|0);
          HEAP32[$351>>2] = $347;
          $352 = ((($347)) + 8|0);
          HEAP32[$352>>2] = $350;
          $$3349$i = $347;
         }
        } while(0);
        $365 = ($345|0)==(0|0);
        do {
         if ($365) {
          $448 = $243;
         } else {
          $366 = ((($$4$lcssa$i)) + 28|0);
          $367 = HEAP32[$366>>2]|0;
          $368 = (136300 + ($367<<2)|0);
          $369 = HEAP32[$368>>2]|0;
          $370 = ($$4$lcssa$i|0)==($369|0);
          if ($370) {
           HEAP32[$368>>2] = $$3349$i;
           $cond$i202 = ($$3349$i|0)==(0|0);
           if ($cond$i202) {
            $371 = 1 << $367;
            $372 = $371 ^ -1;
            $373 = $243 & $372;
            HEAP32[(136000)>>2] = $373;
            $448 = $373;
            break;
           }
          } else {
           $374 = ((($345)) + 16|0);
           $375 = HEAP32[$374>>2]|0;
           $376 = ($375|0)!=($$4$lcssa$i|0);
           $$sink3$i = $376&1;
           $377 = (((($345)) + 16|0) + ($$sink3$i<<2)|0);
           HEAP32[$377>>2] = $$3349$i;
           $378 = ($$3349$i|0)==(0|0);
           if ($378) {
            $448 = $243;
            break;
           }
          }
          $379 = ((($$3349$i)) + 24|0);
          HEAP32[$379>>2] = $345;
          $380 = ((($$4$lcssa$i)) + 16|0);
          $381 = HEAP32[$380>>2]|0;
          $382 = ($381|0)==(0|0);
          if (!($382)) {
           $383 = ((($$3349$i)) + 16|0);
           HEAP32[$383>>2] = $381;
           $384 = ((($381)) + 24|0);
           HEAP32[$384>>2] = $$3349$i;
          }
          $385 = ((($$4$lcssa$i)) + 20|0);
          $386 = HEAP32[$385>>2]|0;
          $387 = ($386|0)==(0|0);
          if ($387) {
           $448 = $243;
          } else {
           $388 = ((($$3349$i)) + 20|0);
           HEAP32[$388>>2] = $386;
           $389 = ((($386)) + 24|0);
           HEAP32[$389>>2] = $$3349$i;
           $448 = $243;
          }
         }
        } while(0);
        $390 = ($$4329$lcssa$i>>>0)<(16);
        do {
         if ($390) {
          $391 = (($$4329$lcssa$i) + ($242))|0;
          $392 = $391 | 3;
          $393 = ((($$4$lcssa$i)) + 4|0);
          HEAP32[$393>>2] = $392;
          $394 = (($$4$lcssa$i) + ($391)|0);
          $395 = ((($394)) + 4|0);
          $396 = HEAP32[$395>>2]|0;
          $397 = $396 | 1;
          HEAP32[$395>>2] = $397;
         } else {
          $398 = $242 | 3;
          $399 = ((($$4$lcssa$i)) + 4|0);
          HEAP32[$399>>2] = $398;
          $400 = $$4329$lcssa$i | 1;
          $401 = ((($342)) + 4|0);
          HEAP32[$401>>2] = $400;
          $402 = (($342) + ($$4329$lcssa$i)|0);
          HEAP32[$402>>2] = $$4329$lcssa$i;
          $403 = $$4329$lcssa$i >>> 3;
          $404 = ($$4329$lcssa$i>>>0)<(256);
          if ($404) {
           $405 = $403 << 1;
           $406 = (136036 + ($405<<2)|0);
           $407 = HEAP32[33999]|0;
           $408 = 1 << $403;
           $409 = $407 & $408;
           $410 = ($409|0)==(0);
           if ($410) {
            $411 = $407 | $408;
            HEAP32[33999] = $411;
            $$pre$i203 = ((($406)) + 8|0);
            $$0345$i = $406;$$pre$phi$i204Z2D = $$pre$i203;
           } else {
            $412 = ((($406)) + 8|0);
            $413 = HEAP32[$412>>2]|0;
            $$0345$i = $413;$$pre$phi$i204Z2D = $412;
           }
           HEAP32[$$pre$phi$i204Z2D>>2] = $342;
           $414 = ((($$0345$i)) + 12|0);
           HEAP32[$414>>2] = $342;
           $415 = ((($342)) + 8|0);
           HEAP32[$415>>2] = $$0345$i;
           $416 = ((($342)) + 12|0);
           HEAP32[$416>>2] = $406;
           break;
          }
          $417 = $$4329$lcssa$i >>> 8;
          $418 = ($417|0)==(0);
          if ($418) {
           $$0339$i = 0;
          } else {
           $419 = ($$4329$lcssa$i>>>0)>(16777215);
           if ($419) {
            $$0339$i = 31;
           } else {
            $420 = (($417) + 1048320)|0;
            $421 = $420 >>> 16;
            $422 = $421 & 8;
            $423 = $417 << $422;
            $424 = (($423) + 520192)|0;
            $425 = $424 >>> 16;
            $426 = $425 & 4;
            $427 = $426 | $422;
            $428 = $423 << $426;
            $429 = (($428) + 245760)|0;
            $430 = $429 >>> 16;
            $431 = $430 & 2;
            $432 = $427 | $431;
            $433 = (14 - ($432))|0;
            $434 = $428 << $431;
            $435 = $434 >>> 15;
            $436 = (($433) + ($435))|0;
            $437 = $436 << 1;
            $438 = (($436) + 7)|0;
            $439 = $$4329$lcssa$i >>> $438;
            $440 = $439 & 1;
            $441 = $440 | $437;
            $$0339$i = $441;
           }
          }
          $442 = (136300 + ($$0339$i<<2)|0);
          $443 = ((($342)) + 28|0);
          HEAP32[$443>>2] = $$0339$i;
          $444 = ((($342)) + 16|0);
          $445 = ((($444)) + 4|0);
          HEAP32[$445>>2] = 0;
          HEAP32[$444>>2] = 0;
          $446 = 1 << $$0339$i;
          $447 = $448 & $446;
          $449 = ($447|0)==(0);
          if ($449) {
           $450 = $448 | $446;
           HEAP32[(136000)>>2] = $450;
           HEAP32[$442>>2] = $342;
           $451 = ((($342)) + 24|0);
           HEAP32[$451>>2] = $442;
           $452 = ((($342)) + 12|0);
           HEAP32[$452>>2] = $342;
           $453 = ((($342)) + 8|0);
           HEAP32[$453>>2] = $342;
           break;
          }
          $454 = HEAP32[$442>>2]|0;
          $455 = ($$0339$i|0)==(31);
          $456 = $$0339$i >>> 1;
          $457 = (25 - ($456))|0;
          $458 = $455 ? 0 : $457;
          $459 = $$4329$lcssa$i << $458;
          $$0322$i = $459;$$0323$i = $454;
          while(1) {
           $460 = ((($$0323$i)) + 4|0);
           $461 = HEAP32[$460>>2]|0;
           $462 = $461 & -8;
           $463 = ($462|0)==($$4329$lcssa$i|0);
           if ($463) {
            label = 106;
            break;
           }
           $464 = $$0322$i >>> 31;
           $465 = (((($$0323$i)) + 16|0) + ($464<<2)|0);
           $466 = $$0322$i << 1;
           $467 = HEAP32[$465>>2]|0;
           $468 = ($467|0)==(0|0);
           if ($468) {
            label = 105;
            break;
           } else {
            $$0322$i = $466;$$0323$i = $467;
           }
          }
          if ((label|0) == 105) {
           HEAP32[$465>>2] = $342;
           $469 = ((($342)) + 24|0);
           HEAP32[$469>>2] = $$0323$i;
           $470 = ((($342)) + 12|0);
           HEAP32[$470>>2] = $342;
           $471 = ((($342)) + 8|0);
           HEAP32[$471>>2] = $342;
           break;
          }
          else if ((label|0) == 106) {
           $472 = ((($$0323$i)) + 8|0);
           $473 = HEAP32[$472>>2]|0;
           $474 = ((($473)) + 12|0);
           HEAP32[$474>>2] = $342;
           HEAP32[$472>>2] = $342;
           $475 = ((($342)) + 8|0);
           HEAP32[$475>>2] = $473;
           $476 = ((($342)) + 12|0);
           HEAP32[$476>>2] = $$0323$i;
           $477 = ((($342)) + 24|0);
           HEAP32[$477>>2] = 0;
           break;
          }
         }
        } while(0);
        $478 = ((($$4$lcssa$i)) + 8|0);
        $$2 = $478;
       } else {
        $$2 = 0;
       }
      } else {
       $$0193 = $242;
       label = 108;
      }
     }
    }
   }
  }
 } while(0);
 L151: do {
  if ((label|0) == 108) {
   $479 = HEAP32[(136004)>>2]|0;
   $480 = ($479>>>0)<($$0193>>>0);
   if (!($480)) {
    $481 = (($479) - ($$0193))|0;
    $482 = HEAP32[(136016)>>2]|0;
    $483 = ($481>>>0)>(15);
    if ($483) {
     $484 = (($482) + ($$0193)|0);
     HEAP32[(136016)>>2] = $484;
     HEAP32[(136004)>>2] = $481;
     $485 = $481 | 1;
     $486 = ((($484)) + 4|0);
     HEAP32[$486>>2] = $485;
     $487 = (($482) + ($479)|0);
     HEAP32[$487>>2] = $481;
     $488 = $$0193 | 3;
     $489 = ((($482)) + 4|0);
     HEAP32[$489>>2] = $488;
    } else {
     HEAP32[(136004)>>2] = 0;
     HEAP32[(136016)>>2] = 0;
     $490 = $479 | 3;
     $491 = ((($482)) + 4|0);
     HEAP32[$491>>2] = $490;
     $492 = (($482) + ($479)|0);
     $493 = ((($492)) + 4|0);
     $494 = HEAP32[$493>>2]|0;
     $495 = $494 | 1;
     HEAP32[$493>>2] = $495;
    }
    $496 = ((($482)) + 8|0);
    $$2 = $496;
    break;
   }
   $497 = HEAP32[(136008)>>2]|0;
   $498 = ($497>>>0)>($$0193>>>0);
   if ($498) {
    $499 = (($497) - ($$0193))|0;
    HEAP32[(136008)>>2] = $499;
    $500 = HEAP32[(136020)>>2]|0;
    $501 = (($500) + ($$0193)|0);
    HEAP32[(136020)>>2] = $501;
    $502 = $499 | 1;
    $503 = ((($501)) + 4|0);
    HEAP32[$503>>2] = $502;
    $504 = $$0193 | 3;
    $505 = ((($500)) + 4|0);
    HEAP32[$505>>2] = $504;
    $506 = ((($500)) + 8|0);
    $$2 = $506;
    break;
   }
   $507 = HEAP32[33986]|0;
   $508 = ($507|0)==(0);
   if ($508) {
    (___pthread_mutex_lock(135968)|0);
    $509 = HEAP32[33986]|0;
    $510 = ($509|0)==(0);
    if ($510) {
     HEAP32[(135952)>>2] = 4096;
     HEAP32[(135948)>>2] = 4096;
     HEAP32[(135956)>>2] = -1;
     HEAP32[(135960)>>2] = -1;
     HEAP32[(135964)>>2] = 2;
     HEAP32[(136440)>>2] = 2;
     $511 = (_pthread_mutexattr_init($1)|0);
     $512 = ($511|0)==(0);
     if ($512) {
      $513 = (_pthread_mutex_init((136444),$1)|0);
      $514 = ($513|0)==(0);
      if ($514) {
      }
     }
     $515 = $2;
     $516 = $515 & -16;
     $517 = $516 ^ 1431655768;
     Atomics_store(HEAP32,33986,$517)|0;
    }
    (___pthread_mutex_unlock(135968)|0);
   }
   $518 = (($$0193) + 48)|0;
   $519 = HEAP32[(135952)>>2]|0;
   $520 = (($$0193) + 47)|0;
   $521 = (($519) + ($520))|0;
   $522 = (0 - ($519))|0;
   $523 = $521 & $522;
   $524 = ($523>>>0)>($$0193>>>0);
   if ($524) {
    $525 = HEAP32[(136436)>>2]|0;
    $526 = ($525|0)==(0);
    if (!($526)) {
     $527 = HEAP32[(136428)>>2]|0;
     $528 = (($527) + ($523))|0;
     $529 = ($528>>>0)<=($527>>>0);
     $530 = ($528>>>0)>($525>>>0);
     $or$cond1$i205 = $529 | $530;
     if ($or$cond1$i205) {
      $$2 = 0;
      break;
     }
    }
    $531 = HEAP32[(136440)>>2]|0;
    $532 = $531 & 4;
    $533 = ($532|0)==(0);
    if ($533) {
     $534 = HEAP32[(136020)>>2]|0;
     $535 = ($534|0)==(0|0);
     L179: do {
      if ($535) {
       label = 131;
      } else {
       $$0$i$i = (136472);
       while(1) {
        $536 = HEAP32[$$0$i$i>>2]|0;
        $537 = ($536>>>0)>($534>>>0);
        if (!($537)) {
         $538 = ((($$0$i$i)) + 4|0);
         $539 = HEAP32[$538>>2]|0;
         $540 = (($536) + ($539)|0);
         $541 = ($540>>>0)>($534>>>0);
         if ($541) {
          break;
         }
        }
        $542 = ((($$0$i$i)) + 8|0);
        $543 = HEAP32[$542>>2]|0;
        $544 = ($543|0)==(0|0);
        if ($544) {
         label = 131;
         break L179;
        } else {
         $$0$i$i = $543;
        }
       }
       (___pthread_mutex_lock(135968)|0);
       $567 = HEAP32[(136008)>>2]|0;
       $568 = HEAP32[(135952)>>2]|0;
       $569 = (($520) - ($567))|0;
       $570 = (($569) + ($568))|0;
       $571 = (0 - ($568))|0;
       $572 = $570 & $571;
       $573 = ($572>>>0)<(2147483647);
       if ($573) {
        $574 = (_sbrk(($572|0))|0);
        $575 = HEAP32[$$0$i$i>>2]|0;
        $576 = HEAP32[$538>>2]|0;
        $577 = (($575) + ($576)|0);
        $578 = ($574|0)==($577|0);
        if ($578) {
         $579 = ($574|0)==((-1)|0);
         if ($579) {
          $$2234243136$i = $572;
          label = 145;
         } else {
          $$3229$i = $574;$$3235$i = $572;
         }
        } else {
         $$2247$ph$i = $574;$$2253$ph$i = $572;
         label = 139;
        }
       } else {
        $$2234243136$i = 0;
        label = 145;
       }
      }
     } while(0);
     do {
      if ((label|0) == 131) {
       (___pthread_mutex_lock(135968)|0);
       $545 = (_sbrk(0)|0);
       $546 = ($545|0)==((-1)|0);
       if ($546) {
        $$2234243136$i = 0;
        label = 145;
       } else {
        $547 = $545;
        $548 = HEAP32[(135948)>>2]|0;
        $549 = (($548) + -1)|0;
        $550 = $549 & $547;
        $551 = ($550|0)==(0);
        $552 = (($549) + ($547))|0;
        $553 = (0 - ($548))|0;
        $554 = $552 & $553;
        $555 = (($554) - ($547))|0;
        $556 = $551 ? 0 : $555;
        $$$i = (($556) + ($523))|0;
        $557 = HEAP32[(136428)>>2]|0;
        $558 = (($$$i) + ($557))|0;
        $559 = ($$$i>>>0)>($$0193>>>0);
        $560 = ($$$i>>>0)<(2147483647);
        $or$cond$i206 = $559 & $560;
        if ($or$cond$i206) {
         $561 = HEAP32[(136436)>>2]|0;
         $562 = ($561|0)==(0);
         if (!($562)) {
          $563 = ($558>>>0)<=($557>>>0);
          $564 = ($558>>>0)>($561>>>0);
          $or$cond2$i = $563 | $564;
          if ($or$cond2$i) {
           $$2234243136$i = 0;
           label = 145;
           break;
          }
         }
         $565 = (_sbrk(($$$i|0))|0);
         $566 = ($565|0)==($545|0);
         if ($566) {
          $$3229$i = $545;$$3235$i = $$$i;
         } else {
          $$2247$ph$i = $565;$$2253$ph$i = $$$i;
          label = 139;
         }
        } else {
         $$2234243136$i = 0;
         label = 145;
        }
       }
      }
     } while(0);
     do {
      if ((label|0) == 139) {
       $580 = (0 - ($$2253$ph$i))|0;
       $581 = ($$2247$ph$i|0)!=((-1)|0);
       $582 = ($$2253$ph$i>>>0)<(2147483647);
       $or$cond7$i = $582 & $581;
       $583 = ($518>>>0)>($$2253$ph$i>>>0);
       $or$cond10$i = $583 & $or$cond7$i;
       if (!($or$cond10$i)) {
        $593 = ($$2247$ph$i|0)==((-1)|0);
        if ($593) {
         $$2234243136$i = 0;
         label = 145;
         break;
        } else {
         $$3229$i = $$2247$ph$i;$$3235$i = $$2253$ph$i;
         break;
        }
       }
       $584 = HEAP32[(135952)>>2]|0;
       $585 = (($520) - ($$2253$ph$i))|0;
       $586 = (($585) + ($584))|0;
       $587 = (0 - ($584))|0;
       $588 = $586 & $587;
       $589 = ($588>>>0)<(2147483647);
       if ($589) {
        $590 = (_sbrk(($588|0))|0);
        $591 = ($590|0)==((-1)|0);
        if ($591) {
         (_sbrk(($580|0))|0);
         $$2234243136$i = 0;
         label = 145;
         break;
        } else {
         $592 = (($588) + ($$2253$ph$i))|0;
         $$3229$i = $$2247$ph$i;$$3235$i = $592;
         break;
        }
       } else {
        $$3229$i = $$2247$ph$i;$$3235$i = $$2253$ph$i;
       }
      }
     } while(0);
     if ((label|0) == 145) {
      $594 = HEAP32[(136440)>>2]|0;
      $595 = $594 | 4;
      HEAP32[(136440)>>2] = $595;
      $$3229$i = (-1);$$3235$i = $$2234243136$i;
     }
     (___pthread_mutex_unlock(135968)|0);
     $$4230$i = $$3229$i;$$4236$i = $$3235$i;
    } else {
     $$4230$i = (-1);$$4236$i = 0;
    }
    $596 = ($$4230$i|0)==((-1)|0);
    $597 = ($523>>>0)<(2147483647);
    $or$cond9$i = $597 & $596;
    if ($or$cond9$i) {
     (___pthread_mutex_lock(135968)|0);
     $598 = (_sbrk(($523|0))|0);
     $599 = (_sbrk(0)|0);
     (___pthread_mutex_unlock(135968)|0);
     $600 = ($598|0)!=((-1)|0);
     $601 = ($599|0)!=((-1)|0);
     $or$cond5$i = $600 & $601;
     $602 = ($598>>>0)<($599>>>0);
     $or$cond11$i = $602 & $or$cond5$i;
     $603 = $599;
     $604 = $598;
     $605 = (($603) - ($604))|0;
     $606 = (($$0193) + 40)|0;
     $607 = ($605>>>0)>($606>>>0);
     $$$4236$i = $607 ? $605 : $$4236$i;
     $$$4230$i = $607 ? $598 : (-1);
     if ($or$cond11$i) {
      $$7$i = $$$4230$i;$$7239$i = $$$4236$i;
      label = 149;
     }
    } else {
     $$7$i = $$4230$i;$$7239$i = $$4236$i;
     label = 149;
    }
    if ((label|0) == 149) {
     $608 = ($$7$i|0)==((-1)|0);
     if (!($608)) {
      $609 = HEAP32[(136428)>>2]|0;
      $610 = (($609) + ($$7239$i))|0;
      HEAP32[(136428)>>2] = $610;
      $611 = HEAP32[(136432)>>2]|0;
      $612 = ($610>>>0)>($611>>>0);
      if ($612) {
       HEAP32[(136432)>>2] = $610;
      }
      $613 = HEAP32[(136020)>>2]|0;
      $614 = ($613|0)==(0|0);
      do {
       if ($614) {
        $615 = HEAP32[(136012)>>2]|0;
        $616 = ($615|0)==(0|0);
        $617 = ($$7$i>>>0)<($615>>>0);
        $or$cond12$i = $616 | $617;
        if ($or$cond12$i) {
         HEAP32[(136012)>>2] = $$7$i;
        }
        HEAP32[(136472)>>2] = $$7$i;
        HEAP32[(136476)>>2] = $$7239$i;
        HEAP32[(136484)>>2] = 0;
        $618 = HEAP32[33986]|0;
        HEAP32[(136032)>>2] = $618;
        HEAP32[(136028)>>2] = -1;
        HEAP32[(136048)>>2] = (136036);
        HEAP32[(136044)>>2] = (136036);
        HEAP32[(136056)>>2] = (136044);
        HEAP32[(136052)>>2] = (136044);
        HEAP32[(136064)>>2] = (136052);
        HEAP32[(136060)>>2] = (136052);
        HEAP32[(136072)>>2] = (136060);
        HEAP32[(136068)>>2] = (136060);
        HEAP32[(136080)>>2] = (136068);
        HEAP32[(136076)>>2] = (136068);
        HEAP32[(136088)>>2] = (136076);
        HEAP32[(136084)>>2] = (136076);
        HEAP32[(136096)>>2] = (136084);
        HEAP32[(136092)>>2] = (136084);
        HEAP32[(136104)>>2] = (136092);
        HEAP32[(136100)>>2] = (136092);
        HEAP32[(136112)>>2] = (136100);
        HEAP32[(136108)>>2] = (136100);
        HEAP32[(136120)>>2] = (136108);
        HEAP32[(136116)>>2] = (136108);
        HEAP32[(136128)>>2] = (136116);
        HEAP32[(136124)>>2] = (136116);
        HEAP32[(136136)>>2] = (136124);
        HEAP32[(136132)>>2] = (136124);
        HEAP32[(136144)>>2] = (136132);
        HEAP32[(136140)>>2] = (136132);
        HEAP32[(136152)>>2] = (136140);
        HEAP32[(136148)>>2] = (136140);
        HEAP32[(136160)>>2] = (136148);
        HEAP32[(136156)>>2] = (136148);
        HEAP32[(136168)>>2] = (136156);
        HEAP32[(136164)>>2] = (136156);
        HEAP32[(136176)>>2] = (136164);
        HEAP32[(136172)>>2] = (136164);
        HEAP32[(136184)>>2] = (136172);
        HEAP32[(136180)>>2] = (136172);
        HEAP32[(136192)>>2] = (136180);
        HEAP32[(136188)>>2] = (136180);
        HEAP32[(136200)>>2] = (136188);
        HEAP32[(136196)>>2] = (136188);
        HEAP32[(136208)>>2] = (136196);
        HEAP32[(136204)>>2] = (136196);
        HEAP32[(136216)>>2] = (136204);
        HEAP32[(136212)>>2] = (136204);
        HEAP32[(136224)>>2] = (136212);
        HEAP32[(136220)>>2] = (136212);
        HEAP32[(136232)>>2] = (136220);
        HEAP32[(136228)>>2] = (136220);
        HEAP32[(136240)>>2] = (136228);
        HEAP32[(136236)>>2] = (136228);
        HEAP32[(136248)>>2] = (136236);
        HEAP32[(136244)>>2] = (136236);
        HEAP32[(136256)>>2] = (136244);
        HEAP32[(136252)>>2] = (136244);
        HEAP32[(136264)>>2] = (136252);
        HEAP32[(136260)>>2] = (136252);
        HEAP32[(136272)>>2] = (136260);
        HEAP32[(136268)>>2] = (136260);
        HEAP32[(136280)>>2] = (136268);
        HEAP32[(136276)>>2] = (136268);
        HEAP32[(136288)>>2] = (136276);
        HEAP32[(136284)>>2] = (136276);
        HEAP32[(136296)>>2] = (136284);
        HEAP32[(136292)>>2] = (136284);
        $619 = (($$7239$i) + -40)|0;
        $620 = ((($$7$i)) + 8|0);
        $621 = $620;
        $622 = $621 & 7;
        $623 = ($622|0)==(0);
        $624 = (0 - ($621))|0;
        $625 = $624 & 7;
        $626 = $623 ? 0 : $625;
        $627 = (($$7$i) + ($626)|0);
        $628 = (($619) - ($626))|0;
        HEAP32[(136020)>>2] = $627;
        HEAP32[(136008)>>2] = $628;
        $629 = $628 | 1;
        $630 = ((($627)) + 4|0);
        HEAP32[$630>>2] = $629;
        $631 = (($$7$i) + ($619)|0);
        $632 = ((($631)) + 4|0);
        HEAP32[$632>>2] = 40;
        $633 = HEAP32[(135960)>>2]|0;
        HEAP32[(136024)>>2] = $633;
       } else {
        $$024359$i = (136472);
        while(1) {
         $634 = HEAP32[$$024359$i>>2]|0;
         $635 = ((($$024359$i)) + 4|0);
         $636 = HEAP32[$635>>2]|0;
         $637 = (($634) + ($636)|0);
         $638 = ($$7$i|0)==($637|0);
         if ($638) {
          label = 158;
          break;
         }
         $639 = ((($$024359$i)) + 8|0);
         $640 = HEAP32[$639>>2]|0;
         $641 = ($640|0)==(0|0);
         if ($641) {
          break;
         } else {
          $$024359$i = $640;
         }
        }
        if ((label|0) == 158) {
         $642 = ((($$024359$i)) + 12|0);
         $643 = HEAP32[$642>>2]|0;
         $644 = $643 & 8;
         $645 = ($644|0)==(0);
         if ($645) {
          $646 = ($634>>>0)<=($613>>>0);
          $647 = ($$7$i>>>0)>($613>>>0);
          $or$cond42$i = $647 & $646;
          if ($or$cond42$i) {
           $648 = (($636) + ($$7239$i))|0;
           HEAP32[$635>>2] = $648;
           $649 = HEAP32[(136008)>>2]|0;
           $650 = (($649) + ($$7239$i))|0;
           $651 = ((($613)) + 8|0);
           $652 = $651;
           $653 = $652 & 7;
           $654 = ($653|0)==(0);
           $655 = (0 - ($652))|0;
           $656 = $655 & 7;
           $657 = $654 ? 0 : $656;
           $658 = (($613) + ($657)|0);
           $659 = (($650) - ($657))|0;
           HEAP32[(136020)>>2] = $658;
           HEAP32[(136008)>>2] = $659;
           $660 = $659 | 1;
           $661 = ((($658)) + 4|0);
           HEAP32[$661>>2] = $660;
           $662 = (($613) + ($650)|0);
           $663 = ((($662)) + 4|0);
           HEAP32[$663>>2] = 40;
           $664 = HEAP32[(135960)>>2]|0;
           HEAP32[(136024)>>2] = $664;
           break;
          }
         }
        }
        $665 = HEAP32[(136012)>>2]|0;
        $666 = ($$7$i>>>0)<($665>>>0);
        if ($666) {
         HEAP32[(136012)>>2] = $$7$i;
        }
        $667 = (($$7$i) + ($$7239$i)|0);
        $$124458$i = (136472);
        while(1) {
         $668 = HEAP32[$$124458$i>>2]|0;
         $669 = ($668|0)==($667|0);
         if ($669) {
          label = 166;
          break;
         }
         $670 = ((($$124458$i)) + 8|0);
         $671 = HEAP32[$670>>2]|0;
         $672 = ($671|0)==(0|0);
         if ($672) {
          $$0$i$i$i = (136472);
          break;
         } else {
          $$124458$i = $671;
         }
        }
        if ((label|0) == 166) {
         $673 = ((($$124458$i)) + 12|0);
         $674 = HEAP32[$673>>2]|0;
         $675 = $674 & 8;
         $676 = ($675|0)==(0);
         if ($676) {
          HEAP32[$$124458$i>>2] = $$7$i;
          $677 = ((($$124458$i)) + 4|0);
          $678 = HEAP32[$677>>2]|0;
          $679 = (($678) + ($$7239$i))|0;
          HEAP32[$677>>2] = $679;
          $680 = ((($$7$i)) + 8|0);
          $681 = $680;
          $682 = $681 & 7;
          $683 = ($682|0)==(0);
          $684 = (0 - ($681))|0;
          $685 = $684 & 7;
          $686 = $683 ? 0 : $685;
          $687 = (($$7$i) + ($686)|0);
          $688 = ((($667)) + 8|0);
          $689 = $688;
          $690 = $689 & 7;
          $691 = ($690|0)==(0);
          $692 = (0 - ($689))|0;
          $693 = $692 & 7;
          $694 = $691 ? 0 : $693;
          $695 = (($667) + ($694)|0);
          $696 = $695;
          $697 = $687;
          $698 = (($696) - ($697))|0;
          $699 = (($687) + ($$0193)|0);
          $700 = (($698) - ($$0193))|0;
          $701 = $$0193 | 3;
          $702 = ((($687)) + 4|0);
          HEAP32[$702>>2] = $701;
          $703 = ($613|0)==($695|0);
          do {
           if ($703) {
            $704 = HEAP32[(136008)>>2]|0;
            $705 = (($704) + ($700))|0;
            HEAP32[(136008)>>2] = $705;
            HEAP32[(136020)>>2] = $699;
            $706 = $705 | 1;
            $707 = ((($699)) + 4|0);
            HEAP32[$707>>2] = $706;
           } else {
            $708 = HEAP32[(136016)>>2]|0;
            $709 = ($708|0)==($695|0);
            if ($709) {
             $710 = HEAP32[(136004)>>2]|0;
             $711 = (($710) + ($700))|0;
             HEAP32[(136004)>>2] = $711;
             HEAP32[(136016)>>2] = $699;
             $712 = $711 | 1;
             $713 = ((($699)) + 4|0);
             HEAP32[$713>>2] = $712;
             $714 = (($699) + ($711)|0);
             HEAP32[$714>>2] = $711;
             break;
            }
            $715 = ((($695)) + 4|0);
            $716 = HEAP32[$715>>2]|0;
            $717 = $716 & 3;
            $718 = ($717|0)==(1);
            if ($718) {
             $719 = $716 & -8;
             $720 = $716 >>> 3;
             $721 = ($716>>>0)<(256);
             L247: do {
              if ($721) {
               $722 = ((($695)) + 8|0);
               $723 = HEAP32[$722>>2]|0;
               $724 = ((($695)) + 12|0);
               $725 = HEAP32[$724>>2]|0;
               $726 = ($725|0)==($723|0);
               if ($726) {
                $727 = 1 << $720;
                $728 = $727 ^ -1;
                $729 = HEAP32[33999]|0;
                $730 = $729 & $728;
                HEAP32[33999] = $730;
                break;
               } else {
                $731 = ((($723)) + 12|0);
                HEAP32[$731>>2] = $725;
                $732 = ((($725)) + 8|0);
                HEAP32[$732>>2] = $723;
                break;
               }
              } else {
               $733 = ((($695)) + 24|0);
               $734 = HEAP32[$733>>2]|0;
               $735 = ((($695)) + 12|0);
               $736 = HEAP32[$735>>2]|0;
               $737 = ($736|0)==($695|0);
               do {
                if ($737) {
                 $742 = ((($695)) + 16|0);
                 $743 = ((($742)) + 4|0);
                 $744 = HEAP32[$743>>2]|0;
                 $745 = ($744|0)==(0|0);
                 if ($745) {
                  $746 = HEAP32[$742>>2]|0;
                  $747 = ($746|0)==(0|0);
                  if ($747) {
                   $$3$i$i = 0;
                   break;
                  } else {
                   $$1264$i$i = $746;$$1266$i$i = $742;
                  }
                 } else {
                  $$1264$i$i = $744;$$1266$i$i = $743;
                 }
                 while(1) {
                  $748 = ((($$1264$i$i)) + 20|0);
                  $749 = HEAP32[$748>>2]|0;
                  $750 = ($749|0)==(0|0);
                  if (!($750)) {
                   $$1264$i$i = $749;$$1266$i$i = $748;
                   continue;
                  }
                  $751 = ((($$1264$i$i)) + 16|0);
                  $752 = HEAP32[$751>>2]|0;
                  $753 = ($752|0)==(0|0);
                  if ($753) {
                   break;
                  } else {
                   $$1264$i$i = $752;$$1266$i$i = $751;
                  }
                 }
                 HEAP32[$$1266$i$i>>2] = 0;
                 $$3$i$i = $$1264$i$i;
                } else {
                 $738 = ((($695)) + 8|0);
                 $739 = HEAP32[$738>>2]|0;
                 $740 = ((($739)) + 12|0);
                 HEAP32[$740>>2] = $736;
                 $741 = ((($736)) + 8|0);
                 HEAP32[$741>>2] = $739;
                 $$3$i$i = $736;
                }
               } while(0);
               $754 = ($734|0)==(0|0);
               if ($754) {
                break;
               }
               $755 = ((($695)) + 28|0);
               $756 = HEAP32[$755>>2]|0;
               $757 = (136300 + ($756<<2)|0);
               $758 = HEAP32[$757>>2]|0;
               $759 = ($758|0)==($695|0);
               do {
                if ($759) {
                 HEAP32[$757>>2] = $$3$i$i;
                 $cond$i$i = ($$3$i$i|0)==(0|0);
                 if (!($cond$i$i)) {
                  break;
                 }
                 $760 = 1 << $756;
                 $761 = $760 ^ -1;
                 $762 = HEAP32[(136000)>>2]|0;
                 $763 = $762 & $761;
                 HEAP32[(136000)>>2] = $763;
                 break L247;
                } else {
                 $764 = ((($734)) + 16|0);
                 $765 = HEAP32[$764>>2]|0;
                 $766 = ($765|0)!=($695|0);
                 $$sink1$i$i = $766&1;
                 $767 = (((($734)) + 16|0) + ($$sink1$i$i<<2)|0);
                 HEAP32[$767>>2] = $$3$i$i;
                 $768 = ($$3$i$i|0)==(0|0);
                 if ($768) {
                  break L247;
                 }
                }
               } while(0);
               $769 = ((($$3$i$i)) + 24|0);
               HEAP32[$769>>2] = $734;
               $770 = ((($695)) + 16|0);
               $771 = HEAP32[$770>>2]|0;
               $772 = ($771|0)==(0|0);
               if (!($772)) {
                $773 = ((($$3$i$i)) + 16|0);
                HEAP32[$773>>2] = $771;
                $774 = ((($771)) + 24|0);
                HEAP32[$774>>2] = $$3$i$i;
               }
               $775 = ((($770)) + 4|0);
               $776 = HEAP32[$775>>2]|0;
               $777 = ($776|0)==(0|0);
               if ($777) {
                break;
               }
               $778 = ((($$3$i$i)) + 20|0);
               HEAP32[$778>>2] = $776;
               $779 = ((($776)) + 24|0);
               HEAP32[$779>>2] = $$3$i$i;
              }
             } while(0);
             $780 = (($695) + ($719)|0);
             $781 = (($719) + ($700))|0;
             $$0$i17$i = $780;$$0260$i$i = $781;
            } else {
             $$0$i17$i = $695;$$0260$i$i = $700;
            }
            $782 = ((($$0$i17$i)) + 4|0);
            $783 = HEAP32[$782>>2]|0;
            $784 = $783 & -2;
            HEAP32[$782>>2] = $784;
            $785 = $$0260$i$i | 1;
            $786 = ((($699)) + 4|0);
            HEAP32[$786>>2] = $785;
            $787 = (($699) + ($$0260$i$i)|0);
            HEAP32[$787>>2] = $$0260$i$i;
            $788 = $$0260$i$i >>> 3;
            $789 = ($$0260$i$i>>>0)<(256);
            if ($789) {
             $790 = $788 << 1;
             $791 = (136036 + ($790<<2)|0);
             $792 = HEAP32[33999]|0;
             $793 = 1 << $788;
             $794 = $792 & $793;
             $795 = ($794|0)==(0);
             if ($795) {
              $796 = $792 | $793;
              HEAP32[33999] = $796;
              $$pre$i$i = ((($791)) + 8|0);
              $$0268$i$i = $791;$$pre$phi$i$iZ2D = $$pre$i$i;
             } else {
              $797 = ((($791)) + 8|0);
              $798 = HEAP32[$797>>2]|0;
              $$0268$i$i = $798;$$pre$phi$i$iZ2D = $797;
             }
             HEAP32[$$pre$phi$i$iZ2D>>2] = $699;
             $799 = ((($$0268$i$i)) + 12|0);
             HEAP32[$799>>2] = $699;
             $800 = ((($699)) + 8|0);
             HEAP32[$800>>2] = $$0268$i$i;
             $801 = ((($699)) + 12|0);
             HEAP32[$801>>2] = $791;
             break;
            }
            $802 = $$0260$i$i >>> 8;
            $803 = ($802|0)==(0);
            do {
             if ($803) {
              $$0269$i$i = 0;
             } else {
              $804 = ($$0260$i$i>>>0)>(16777215);
              if ($804) {
               $$0269$i$i = 31;
               break;
              }
              $805 = (($802) + 1048320)|0;
              $806 = $805 >>> 16;
              $807 = $806 & 8;
              $808 = $802 << $807;
              $809 = (($808) + 520192)|0;
              $810 = $809 >>> 16;
              $811 = $810 & 4;
              $812 = $811 | $807;
              $813 = $808 << $811;
              $814 = (($813) + 245760)|0;
              $815 = $814 >>> 16;
              $816 = $815 & 2;
              $817 = $812 | $816;
              $818 = (14 - ($817))|0;
              $819 = $813 << $816;
              $820 = $819 >>> 15;
              $821 = (($818) + ($820))|0;
              $822 = $821 << 1;
              $823 = (($821) + 7)|0;
              $824 = $$0260$i$i >>> $823;
              $825 = $824 & 1;
              $826 = $825 | $822;
              $$0269$i$i = $826;
             }
            } while(0);
            $827 = (136300 + ($$0269$i$i<<2)|0);
            $828 = ((($699)) + 28|0);
            HEAP32[$828>>2] = $$0269$i$i;
            $829 = ((($699)) + 16|0);
            $830 = ((($829)) + 4|0);
            HEAP32[$830>>2] = 0;
            HEAP32[$829>>2] = 0;
            $831 = HEAP32[(136000)>>2]|0;
            $832 = 1 << $$0269$i$i;
            $833 = $831 & $832;
            $834 = ($833|0)==(0);
            if ($834) {
             $835 = $831 | $832;
             HEAP32[(136000)>>2] = $835;
             HEAP32[$827>>2] = $699;
             $836 = ((($699)) + 24|0);
             HEAP32[$836>>2] = $827;
             $837 = ((($699)) + 12|0);
             HEAP32[$837>>2] = $699;
             $838 = ((($699)) + 8|0);
             HEAP32[$838>>2] = $699;
             break;
            }
            $839 = HEAP32[$827>>2]|0;
            $840 = ($$0269$i$i|0)==(31);
            $841 = $$0269$i$i >>> 1;
            $842 = (25 - ($841))|0;
            $843 = $840 ? 0 : $842;
            $844 = $$0260$i$i << $843;
            $$0261$i$i = $844;$$0262$i$i = $839;
            while(1) {
             $845 = ((($$0262$i$i)) + 4|0);
             $846 = HEAP32[$845>>2]|0;
             $847 = $846 & -8;
             $848 = ($847|0)==($$0260$i$i|0);
             if ($848) {
              label = 207;
              break;
             }
             $849 = $$0261$i$i >>> 31;
             $850 = (((($$0262$i$i)) + 16|0) + ($849<<2)|0);
             $851 = $$0261$i$i << 1;
             $852 = HEAP32[$850>>2]|0;
             $853 = ($852|0)==(0|0);
             if ($853) {
              label = 206;
              break;
             } else {
              $$0261$i$i = $851;$$0262$i$i = $852;
             }
            }
            if ((label|0) == 206) {
             HEAP32[$850>>2] = $699;
             $854 = ((($699)) + 24|0);
             HEAP32[$854>>2] = $$0262$i$i;
             $855 = ((($699)) + 12|0);
             HEAP32[$855>>2] = $699;
             $856 = ((($699)) + 8|0);
             HEAP32[$856>>2] = $699;
             break;
            }
            else if ((label|0) == 207) {
             $857 = ((($$0262$i$i)) + 8|0);
             $858 = HEAP32[$857>>2]|0;
             $859 = ((($858)) + 12|0);
             HEAP32[$859>>2] = $699;
             HEAP32[$857>>2] = $699;
             $860 = ((($699)) + 8|0);
             HEAP32[$860>>2] = $858;
             $861 = ((($699)) + 12|0);
             HEAP32[$861>>2] = $$0262$i$i;
             $862 = ((($699)) + 24|0);
             HEAP32[$862>>2] = 0;
             break;
            }
           }
          } while(0);
          $987 = ((($687)) + 8|0);
          $$2 = $987;
          break L151;
         } else {
          $$0$i$i$i = (136472);
         }
        }
        while(1) {
         $863 = HEAP32[$$0$i$i$i>>2]|0;
         $864 = ($863>>>0)>($613>>>0);
         if (!($864)) {
          $865 = ((($$0$i$i$i)) + 4|0);
          $866 = HEAP32[$865>>2]|0;
          $867 = (($863) + ($866)|0);
          $868 = ($867>>>0)>($613>>>0);
          if ($868) {
           break;
          }
         }
         $869 = ((($$0$i$i$i)) + 8|0);
         $870 = HEAP32[$869>>2]|0;
         $$0$i$i$i = $870;
        }
        $871 = ((($867)) + -47|0);
        $872 = ((($871)) + 8|0);
        $873 = $872;
        $874 = $873 & 7;
        $875 = ($874|0)==(0);
        $876 = (0 - ($873))|0;
        $877 = $876 & 7;
        $878 = $875 ? 0 : $877;
        $879 = (($871) + ($878)|0);
        $880 = ((($613)) + 16|0);
        $881 = ($879>>>0)<($880>>>0);
        $882 = $881 ? $613 : $879;
        $883 = ((($882)) + 8|0);
        $884 = ((($882)) + 24|0);
        $885 = (($$7239$i) + -40)|0;
        $886 = ((($$7$i)) + 8|0);
        $887 = $886;
        $888 = $887 & 7;
        $889 = ($888|0)==(0);
        $890 = (0 - ($887))|0;
        $891 = $890 & 7;
        $892 = $889 ? 0 : $891;
        $893 = (($$7$i) + ($892)|0);
        $894 = (($885) - ($892))|0;
        HEAP32[(136020)>>2] = $893;
        HEAP32[(136008)>>2] = $894;
        $895 = $894 | 1;
        $896 = ((($893)) + 4|0);
        HEAP32[$896>>2] = $895;
        $897 = (($$7$i) + ($885)|0);
        $898 = ((($897)) + 4|0);
        HEAP32[$898>>2] = 40;
        $899 = HEAP32[(135960)>>2]|0;
        HEAP32[(136024)>>2] = $899;
        $900 = ((($882)) + 4|0);
        HEAP32[$900>>2] = 27;
        ;HEAP32[$883>>2]=HEAP32[(136472)>>2]|0;HEAP32[$883+4>>2]=HEAP32[(136472)+4>>2]|0;HEAP32[$883+8>>2]=HEAP32[(136472)+8>>2]|0;HEAP32[$883+12>>2]=HEAP32[(136472)+12>>2]|0;
        HEAP32[(136472)>>2] = $$7$i;
        HEAP32[(136476)>>2] = $$7239$i;
        HEAP32[(136484)>>2] = 0;
        HEAP32[(136480)>>2] = $883;
        $902 = $884;
        while(1) {
         $901 = ((($902)) + 4|0);
         HEAP32[$901>>2] = 7;
         $903 = ((($902)) + 8|0);
         $904 = ($903>>>0)<($867>>>0);
         if ($904) {
          $902 = $901;
         } else {
          break;
         }
        }
        $905 = ($882|0)==($613|0);
        if (!($905)) {
         $906 = $882;
         $907 = $613;
         $908 = (($906) - ($907))|0;
         $909 = HEAP32[$900>>2]|0;
         $910 = $909 & -2;
         HEAP32[$900>>2] = $910;
         $911 = $908 | 1;
         $912 = ((($613)) + 4|0);
         HEAP32[$912>>2] = $911;
         HEAP32[$882>>2] = $908;
         $913 = $908 >>> 3;
         $914 = ($908>>>0)<(256);
         if ($914) {
          $915 = $913 << 1;
          $916 = (136036 + ($915<<2)|0);
          $917 = HEAP32[33999]|0;
          $918 = 1 << $913;
          $919 = $917 & $918;
          $920 = ($919|0)==(0);
          if ($920) {
           $921 = $917 | $918;
           HEAP32[33999] = $921;
           $$pre$i18$i = ((($916)) + 8|0);
           $$0206$i$i = $916;$$pre$phi$i19$iZ2D = $$pre$i18$i;
          } else {
           $922 = ((($916)) + 8|0);
           $923 = HEAP32[$922>>2]|0;
           $$0206$i$i = $923;$$pre$phi$i19$iZ2D = $922;
          }
          HEAP32[$$pre$phi$i19$iZ2D>>2] = $613;
          $924 = ((($$0206$i$i)) + 12|0);
          HEAP32[$924>>2] = $613;
          $925 = ((($613)) + 8|0);
          HEAP32[$925>>2] = $$0206$i$i;
          $926 = ((($613)) + 12|0);
          HEAP32[$926>>2] = $916;
          break;
         }
         $927 = $908 >>> 8;
         $928 = ($927|0)==(0);
         do {
          if ($928) {
           $$0207$i$i = 0;
          } else {
           $929 = ($908>>>0)>(16777215);
           if ($929) {
            $$0207$i$i = 31;
            break;
           }
           $930 = (($927) + 1048320)|0;
           $931 = $930 >>> 16;
           $932 = $931 & 8;
           $933 = $927 << $932;
           $934 = (($933) + 520192)|0;
           $935 = $934 >>> 16;
           $936 = $935 & 4;
           $937 = $936 | $932;
           $938 = $933 << $936;
           $939 = (($938) + 245760)|0;
           $940 = $939 >>> 16;
           $941 = $940 & 2;
           $942 = $937 | $941;
           $943 = (14 - ($942))|0;
           $944 = $938 << $941;
           $945 = $944 >>> 15;
           $946 = (($943) + ($945))|0;
           $947 = $946 << 1;
           $948 = (($946) + 7)|0;
           $949 = $908 >>> $948;
           $950 = $949 & 1;
           $951 = $950 | $947;
           $$0207$i$i = $951;
          }
         } while(0);
         $952 = (136300 + ($$0207$i$i<<2)|0);
         $953 = ((($613)) + 28|0);
         HEAP32[$953>>2] = $$0207$i$i;
         $954 = ((($613)) + 20|0);
         HEAP32[$954>>2] = 0;
         HEAP32[$880>>2] = 0;
         $955 = HEAP32[(136000)>>2]|0;
         $956 = 1 << $$0207$i$i;
         $957 = $955 & $956;
         $958 = ($957|0)==(0);
         if ($958) {
          $959 = $955 | $956;
          HEAP32[(136000)>>2] = $959;
          HEAP32[$952>>2] = $613;
          $960 = ((($613)) + 24|0);
          HEAP32[$960>>2] = $952;
          $961 = ((($613)) + 12|0);
          HEAP32[$961>>2] = $613;
          $962 = ((($613)) + 8|0);
          HEAP32[$962>>2] = $613;
          break;
         }
         $963 = HEAP32[$952>>2]|0;
         $964 = ($$0207$i$i|0)==(31);
         $965 = $$0207$i$i >>> 1;
         $966 = (25 - ($965))|0;
         $967 = $964 ? 0 : $966;
         $968 = $908 << $967;
         $$0201$i$i = $968;$$0202$i$i = $963;
         while(1) {
          $969 = ((($$0202$i$i)) + 4|0);
          $970 = HEAP32[$969>>2]|0;
          $971 = $970 & -8;
          $972 = ($971|0)==($908|0);
          if ($972) {
           label = 228;
           break;
          }
          $973 = $$0201$i$i >>> 31;
          $974 = (((($$0202$i$i)) + 16|0) + ($973<<2)|0);
          $975 = $$0201$i$i << 1;
          $976 = HEAP32[$974>>2]|0;
          $977 = ($976|0)==(0|0);
          if ($977) {
           label = 227;
           break;
          } else {
           $$0201$i$i = $975;$$0202$i$i = $976;
          }
         }
         if ((label|0) == 227) {
          HEAP32[$974>>2] = $613;
          $978 = ((($613)) + 24|0);
          HEAP32[$978>>2] = $$0202$i$i;
          $979 = ((($613)) + 12|0);
          HEAP32[$979>>2] = $613;
          $980 = ((($613)) + 8|0);
          HEAP32[$980>>2] = $613;
          break;
         }
         else if ((label|0) == 228) {
          $981 = ((($$0202$i$i)) + 8|0);
          $982 = HEAP32[$981>>2]|0;
          $983 = ((($982)) + 12|0);
          HEAP32[$983>>2] = $613;
          HEAP32[$981>>2] = $613;
          $984 = ((($613)) + 8|0);
          HEAP32[$984>>2] = $982;
          $985 = ((($613)) + 12|0);
          HEAP32[$985>>2] = $$0202$i$i;
          $986 = ((($613)) + 24|0);
          HEAP32[$986>>2] = 0;
          break;
         }
        }
       }
      } while(0);
      $988 = HEAP32[(136008)>>2]|0;
      $989 = ($988>>>0)>($$0193>>>0);
      if ($989) {
       $990 = (($988) - ($$0193))|0;
       HEAP32[(136008)>>2] = $990;
       $991 = HEAP32[(136020)>>2]|0;
       $992 = (($991) + ($$0193)|0);
       HEAP32[(136020)>>2] = $992;
       $993 = $990 | 1;
       $994 = ((($992)) + 4|0);
       HEAP32[$994>>2] = $993;
       $995 = $$0193 | 3;
       $996 = ((($991)) + 4|0);
       HEAP32[$996>>2] = $995;
       $997 = ((($991)) + 8|0);
       $$2 = $997;
       break;
      }
     }
    }
    $998 = (___errno_location()|0);
    HEAP32[$998>>2] = 12;
    $$2 = 0;
   } else {
    $$2 = 0;
   }
  }
 } while(0);
 $999 = HEAP32[(136440)>>2]|0;
 $1000 = $999 & 2;
 $1001 = ($1000|0)==(0);
 if ($1001) {
  $$1 = $$2;
  STACKTOP = sp;return ($$1|0);
 }
 (___pthread_mutex_unlock((136444))|0);
 $$1 = $$2;
 STACKTOP = sp;return ($$1|0);
}
function _free($0) {
 $0 = $0|0;
 var $$0195$i = 0, $$0195$in$i = 0, $$0348 = 0, $$0349 = 0, $$0361 = 0, $$0368 = 0, $$1 = 0, $$1347 = 0, $$1352 = 0, $$1355 = 0, $$1363 = 0, $$1367 = 0, $$2 = 0, $$3 = 0, $$3365 = 0, $$pre = 0, $$pre$phiZ2D = 0, $$sink3 = 0, $$sink5 = 0, $1 = 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0;
 var $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0;
 var $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0;
 var $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0;
 var $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0;
 var $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0;
 var $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0;
 var $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0;
 var $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0;
 var $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0;
 var $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0;
 var $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0;
 var $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0;
 var $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $cond373 = 0, $cond374 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = ($0|0)==(0|0);
 if ($1) {
  return;
 }
 $2 = ((($0)) + -8|0);
 $3 = HEAP32[(136440)>>2]|0;
 $4 = $3 & 2;
 $5 = ($4|0)==(0);
 if (!($5)) {
  $6 = (___pthread_mutex_lock((136444))|0);
  $7 = ($6|0)==(0);
  if (!($7)) {
   return;
  }
 }
 $8 = HEAP32[(136012)>>2]|0;
 $9 = ((($0)) + -4|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = $10 & -8;
 $12 = (($2) + ($11)|0);
 $13 = $10 & 1;
 $14 = ($13|0)==(0);
 do {
  if ($14) {
   $15 = HEAP32[$2>>2]|0;
   $16 = $10 & 3;
   $17 = ($16|0)==(0);
   if (!($17)) {
    $18 = (0 - ($15))|0;
    $19 = (($2) + ($18)|0);
    $20 = (($15) + ($11))|0;
    $21 = ($19>>>0)<($8>>>0);
    if (!($21)) {
     $22 = HEAP32[(136016)>>2]|0;
     $23 = ($22|0)==($19|0);
     if ($23) {
      $84 = ((($12)) + 4|0);
      $85 = HEAP32[$84>>2]|0;
      $86 = $85 & 3;
      $87 = ($86|0)==(3);
      if (!($87)) {
       $$1 = $19;$$1347 = $20;$93 = $19;
       label = 30;
       break;
      }
      HEAP32[(136004)>>2] = $20;
      $88 = $85 & -2;
      HEAP32[$84>>2] = $88;
      $89 = $20 | 1;
      $90 = ((($19)) + 4|0);
      HEAP32[$90>>2] = $89;
      $91 = (($19) + ($20)|0);
      HEAP32[$91>>2] = $20;
      break;
     }
     $24 = $15 >>> 3;
     $25 = ($15>>>0)<(256);
     if ($25) {
      $26 = ((($19)) + 8|0);
      $27 = HEAP32[$26>>2]|0;
      $28 = ((($19)) + 12|0);
      $29 = HEAP32[$28>>2]|0;
      $30 = ($29|0)==($27|0);
      if ($30) {
       $31 = 1 << $24;
       $32 = $31 ^ -1;
       $33 = HEAP32[33999]|0;
       $34 = $33 & $32;
       HEAP32[33999] = $34;
       $$1 = $19;$$1347 = $20;$93 = $19;
       label = 30;
       break;
      } else {
       $35 = ((($27)) + 12|0);
       HEAP32[$35>>2] = $29;
       $36 = ((($29)) + 8|0);
       HEAP32[$36>>2] = $27;
       $$1 = $19;$$1347 = $20;$93 = $19;
       label = 30;
       break;
      }
     }
     $37 = ((($19)) + 24|0);
     $38 = HEAP32[$37>>2]|0;
     $39 = ((($19)) + 12|0);
     $40 = HEAP32[$39>>2]|0;
     $41 = ($40|0)==($19|0);
     do {
      if ($41) {
       $46 = ((($19)) + 16|0);
       $47 = ((($46)) + 4|0);
       $48 = HEAP32[$47>>2]|0;
       $49 = ($48|0)==(0|0);
       if ($49) {
        $50 = HEAP32[$46>>2]|0;
        $51 = ($50|0)==(0|0);
        if ($51) {
         $$3 = 0;
         break;
        } else {
         $$1352 = $50;$$1355 = $46;
        }
       } else {
        $$1352 = $48;$$1355 = $47;
       }
       while(1) {
        $52 = ((($$1352)) + 20|0);
        $53 = HEAP32[$52>>2]|0;
        $54 = ($53|0)==(0|0);
        if (!($54)) {
         $$1352 = $53;$$1355 = $52;
         continue;
        }
        $55 = ((($$1352)) + 16|0);
        $56 = HEAP32[$55>>2]|0;
        $57 = ($56|0)==(0|0);
        if ($57) {
         break;
        } else {
         $$1352 = $56;$$1355 = $55;
        }
       }
       HEAP32[$$1355>>2] = 0;
       $$3 = $$1352;
      } else {
       $42 = ((($19)) + 8|0);
       $43 = HEAP32[$42>>2]|0;
       $44 = ((($43)) + 12|0);
       HEAP32[$44>>2] = $40;
       $45 = ((($40)) + 8|0);
       HEAP32[$45>>2] = $43;
       $$3 = $40;
      }
     } while(0);
     $58 = ($38|0)==(0|0);
     if ($58) {
      $$1 = $19;$$1347 = $20;$93 = $19;
      label = 30;
     } else {
      $59 = ((($19)) + 28|0);
      $60 = HEAP32[$59>>2]|0;
      $61 = (136300 + ($60<<2)|0);
      $62 = HEAP32[$61>>2]|0;
      $63 = ($62|0)==($19|0);
      if ($63) {
       HEAP32[$61>>2] = $$3;
       $cond373 = ($$3|0)==(0|0);
       if ($cond373) {
        $64 = 1 << $60;
        $65 = $64 ^ -1;
        $66 = HEAP32[(136000)>>2]|0;
        $67 = $66 & $65;
        HEAP32[(136000)>>2] = $67;
        $$1 = $19;$$1347 = $20;$93 = $19;
        label = 30;
        break;
       }
      } else {
       $68 = ((($38)) + 16|0);
       $69 = HEAP32[$68>>2]|0;
       $70 = ($69|0)!=($19|0);
       $$sink3 = $70&1;
       $71 = (((($38)) + 16|0) + ($$sink3<<2)|0);
       HEAP32[$71>>2] = $$3;
       $72 = ($$3|0)==(0|0);
       if ($72) {
        $$1 = $19;$$1347 = $20;$93 = $19;
        label = 30;
        break;
       }
      }
      $73 = ((($$3)) + 24|0);
      HEAP32[$73>>2] = $38;
      $74 = ((($19)) + 16|0);
      $75 = HEAP32[$74>>2]|0;
      $76 = ($75|0)==(0|0);
      if (!($76)) {
       $77 = ((($$3)) + 16|0);
       HEAP32[$77>>2] = $75;
       $78 = ((($75)) + 24|0);
       HEAP32[$78>>2] = $$3;
      }
      $79 = ((($74)) + 4|0);
      $80 = HEAP32[$79>>2]|0;
      $81 = ($80|0)==(0|0);
      if ($81) {
       $$1 = $19;$$1347 = $20;$93 = $19;
       label = 30;
      } else {
       $82 = ((($$3)) + 20|0);
       HEAP32[$82>>2] = $80;
       $83 = ((($80)) + 24|0);
       HEAP32[$83>>2] = $$3;
       $$1 = $19;$$1347 = $20;$93 = $19;
       label = 30;
      }
     }
    }
   }
  } else {
   $$1 = $2;$$1347 = $11;$93 = $2;
   label = 30;
  }
 } while(0);
 do {
  if ((label|0) == 30) {
   $92 = ($93>>>0)<($12>>>0);
   if ($92) {
    $94 = ((($12)) + 4|0);
    $95 = HEAP32[$94>>2]|0;
    $96 = $95 & 1;
    $97 = ($96|0)==(0);
    if (!($97)) {
     $98 = $95 & 2;
     $99 = ($98|0)==(0);
     if ($99) {
      $100 = HEAP32[(136020)>>2]|0;
      $101 = ($100|0)==($12|0);
      if ($101) {
       $102 = HEAP32[(136008)>>2]|0;
       $103 = (($102) + ($$1347))|0;
       HEAP32[(136008)>>2] = $103;
       HEAP32[(136020)>>2] = $$1;
       $104 = $103 | 1;
       $105 = ((($$1)) + 4|0);
       HEAP32[$105>>2] = $104;
       $106 = HEAP32[(136016)>>2]|0;
       $107 = ($$1|0)==($106|0);
       if (!($107)) {
        break;
       }
       HEAP32[(136016)>>2] = 0;
       HEAP32[(136004)>>2] = 0;
       break;
      }
      $108 = HEAP32[(136016)>>2]|0;
      $109 = ($108|0)==($12|0);
      if ($109) {
       $110 = HEAP32[(136004)>>2]|0;
       $111 = (($110) + ($$1347))|0;
       HEAP32[(136004)>>2] = $111;
       HEAP32[(136016)>>2] = $93;
       $112 = $111 | 1;
       $113 = ((($$1)) + 4|0);
       HEAP32[$113>>2] = $112;
       $114 = (($93) + ($111)|0);
       HEAP32[$114>>2] = $111;
       break;
      }
      $115 = $95 & -8;
      $116 = (($115) + ($$1347))|0;
      $117 = $95 >>> 3;
      $118 = ($95>>>0)<(256);
      do {
       if ($118) {
        $119 = ((($12)) + 8|0);
        $120 = HEAP32[$119>>2]|0;
        $121 = ((($12)) + 12|0);
        $122 = HEAP32[$121>>2]|0;
        $123 = ($122|0)==($120|0);
        if ($123) {
         $124 = 1 << $117;
         $125 = $124 ^ -1;
         $126 = HEAP32[33999]|0;
         $127 = $126 & $125;
         HEAP32[33999] = $127;
         break;
        } else {
         $128 = ((($120)) + 12|0);
         HEAP32[$128>>2] = $122;
         $129 = ((($122)) + 8|0);
         HEAP32[$129>>2] = $120;
         break;
        }
       } else {
        $130 = ((($12)) + 24|0);
        $131 = HEAP32[$130>>2]|0;
        $132 = ((($12)) + 12|0);
        $133 = HEAP32[$132>>2]|0;
        $134 = ($133|0)==($12|0);
        do {
         if ($134) {
          $139 = ((($12)) + 16|0);
          $140 = ((($139)) + 4|0);
          $141 = HEAP32[$140>>2]|0;
          $142 = ($141|0)==(0|0);
          if ($142) {
           $143 = HEAP32[$139>>2]|0;
           $144 = ($143|0)==(0|0);
           if ($144) {
            $$3365 = 0;
            break;
           } else {
            $$1363 = $143;$$1367 = $139;
           }
          } else {
           $$1363 = $141;$$1367 = $140;
          }
          while(1) {
           $145 = ((($$1363)) + 20|0);
           $146 = HEAP32[$145>>2]|0;
           $147 = ($146|0)==(0|0);
           if (!($147)) {
            $$1363 = $146;$$1367 = $145;
            continue;
           }
           $148 = ((($$1363)) + 16|0);
           $149 = HEAP32[$148>>2]|0;
           $150 = ($149|0)==(0|0);
           if ($150) {
            break;
           } else {
            $$1363 = $149;$$1367 = $148;
           }
          }
          HEAP32[$$1367>>2] = 0;
          $$3365 = $$1363;
         } else {
          $135 = ((($12)) + 8|0);
          $136 = HEAP32[$135>>2]|0;
          $137 = ((($136)) + 12|0);
          HEAP32[$137>>2] = $133;
          $138 = ((($133)) + 8|0);
          HEAP32[$138>>2] = $136;
          $$3365 = $133;
         }
        } while(0);
        $151 = ($131|0)==(0|0);
        if (!($151)) {
         $152 = ((($12)) + 28|0);
         $153 = HEAP32[$152>>2]|0;
         $154 = (136300 + ($153<<2)|0);
         $155 = HEAP32[$154>>2]|0;
         $156 = ($155|0)==($12|0);
         if ($156) {
          HEAP32[$154>>2] = $$3365;
          $cond374 = ($$3365|0)==(0|0);
          if ($cond374) {
           $157 = 1 << $153;
           $158 = $157 ^ -1;
           $159 = HEAP32[(136000)>>2]|0;
           $160 = $159 & $158;
           HEAP32[(136000)>>2] = $160;
           break;
          }
         } else {
          $161 = ((($131)) + 16|0);
          $162 = HEAP32[$161>>2]|0;
          $163 = ($162|0)!=($12|0);
          $$sink5 = $163&1;
          $164 = (((($131)) + 16|0) + ($$sink5<<2)|0);
          HEAP32[$164>>2] = $$3365;
          $165 = ($$3365|0)==(0|0);
          if ($165) {
           break;
          }
         }
         $166 = ((($$3365)) + 24|0);
         HEAP32[$166>>2] = $131;
         $167 = ((($12)) + 16|0);
         $168 = HEAP32[$167>>2]|0;
         $169 = ($168|0)==(0|0);
         if (!($169)) {
          $170 = ((($$3365)) + 16|0);
          HEAP32[$170>>2] = $168;
          $171 = ((($168)) + 24|0);
          HEAP32[$171>>2] = $$3365;
         }
         $172 = ((($167)) + 4|0);
         $173 = HEAP32[$172>>2]|0;
         $174 = ($173|0)==(0|0);
         if (!($174)) {
          $175 = ((($$3365)) + 20|0);
          HEAP32[$175>>2] = $173;
          $176 = ((($173)) + 24|0);
          HEAP32[$176>>2] = $$3365;
         }
        }
       }
      } while(0);
      $177 = $116 | 1;
      $178 = ((($$1)) + 4|0);
      HEAP32[$178>>2] = $177;
      $179 = (($93) + ($116)|0);
      HEAP32[$179>>2] = $116;
      $180 = HEAP32[(136016)>>2]|0;
      $181 = ($$1|0)==($180|0);
      if ($181) {
       HEAP32[(136004)>>2] = $116;
       break;
      } else {
       $$2 = $116;
      }
     } else {
      $182 = $95 & -2;
      HEAP32[$94>>2] = $182;
      $183 = $$1347 | 1;
      $184 = ((($$1)) + 4|0);
      HEAP32[$184>>2] = $183;
      $185 = (($93) + ($$1347)|0);
      HEAP32[$185>>2] = $$1347;
      $$2 = $$1347;
     }
     $186 = $$2 >>> 3;
     $187 = ($$2>>>0)<(256);
     if ($187) {
      $188 = $186 << 1;
      $189 = (136036 + ($188<<2)|0);
      $190 = HEAP32[33999]|0;
      $191 = 1 << $186;
      $192 = $190 & $191;
      $193 = ($192|0)==(0);
      if ($193) {
       $194 = $190 | $191;
       HEAP32[33999] = $194;
       $$pre = ((($189)) + 8|0);
       $$0368 = $189;$$pre$phiZ2D = $$pre;
      } else {
       $195 = ((($189)) + 8|0);
       $196 = HEAP32[$195>>2]|0;
       $$0368 = $196;$$pre$phiZ2D = $195;
      }
      HEAP32[$$pre$phiZ2D>>2] = $$1;
      $197 = ((($$0368)) + 12|0);
      HEAP32[$197>>2] = $$1;
      $198 = ((($$1)) + 8|0);
      HEAP32[$198>>2] = $$0368;
      $199 = ((($$1)) + 12|0);
      HEAP32[$199>>2] = $189;
      break;
     }
     $200 = $$2 >>> 8;
     $201 = ($200|0)==(0);
     if ($201) {
      $$0361 = 0;
     } else {
      $202 = ($$2>>>0)>(16777215);
      if ($202) {
       $$0361 = 31;
      } else {
       $203 = (($200) + 1048320)|0;
       $204 = $203 >>> 16;
       $205 = $204 & 8;
       $206 = $200 << $205;
       $207 = (($206) + 520192)|0;
       $208 = $207 >>> 16;
       $209 = $208 & 4;
       $210 = $209 | $205;
       $211 = $206 << $209;
       $212 = (($211) + 245760)|0;
       $213 = $212 >>> 16;
       $214 = $213 & 2;
       $215 = $210 | $214;
       $216 = (14 - ($215))|0;
       $217 = $211 << $214;
       $218 = $217 >>> 15;
       $219 = (($216) + ($218))|0;
       $220 = $219 << 1;
       $221 = (($219) + 7)|0;
       $222 = $$2 >>> $221;
       $223 = $222 & 1;
       $224 = $223 | $220;
       $$0361 = $224;
      }
     }
     $225 = (136300 + ($$0361<<2)|0);
     $226 = ((($$1)) + 28|0);
     HEAP32[$226>>2] = $$0361;
     $227 = ((($$1)) + 16|0);
     $228 = ((($$1)) + 20|0);
     HEAP32[$228>>2] = 0;
     HEAP32[$227>>2] = 0;
     $229 = HEAP32[(136000)>>2]|0;
     $230 = 1 << $$0361;
     $231 = $229 & $230;
     $232 = ($231|0)==(0);
     do {
      if ($232) {
       $233 = $229 | $230;
       HEAP32[(136000)>>2] = $233;
       HEAP32[$225>>2] = $$1;
       $234 = ((($$1)) + 24|0);
       HEAP32[$234>>2] = $225;
       $235 = ((($$1)) + 12|0);
       HEAP32[$235>>2] = $$1;
       $236 = ((($$1)) + 8|0);
       HEAP32[$236>>2] = $$1;
      } else {
       $237 = HEAP32[$225>>2]|0;
       $238 = ($$0361|0)==(31);
       $239 = $$0361 >>> 1;
       $240 = (25 - ($239))|0;
       $241 = $238 ? 0 : $240;
       $242 = $$2 << $241;
       $$0348 = $242;$$0349 = $237;
       while(1) {
        $243 = ((($$0349)) + 4|0);
        $244 = HEAP32[$243>>2]|0;
        $245 = $244 & -8;
        $246 = ($245|0)==($$2|0);
        if ($246) {
         label = 75;
         break;
        }
        $247 = $$0348 >>> 31;
        $248 = (((($$0349)) + 16|0) + ($247<<2)|0);
        $249 = $$0348 << 1;
        $250 = HEAP32[$248>>2]|0;
        $251 = ($250|0)==(0|0);
        if ($251) {
         label = 74;
         break;
        } else {
         $$0348 = $249;$$0349 = $250;
        }
       }
       if ((label|0) == 74) {
        HEAP32[$248>>2] = $$1;
        $252 = ((($$1)) + 24|0);
        HEAP32[$252>>2] = $$0349;
        $253 = ((($$1)) + 12|0);
        HEAP32[$253>>2] = $$1;
        $254 = ((($$1)) + 8|0);
        HEAP32[$254>>2] = $$1;
        break;
       }
       else if ((label|0) == 75) {
        $255 = ((($$0349)) + 8|0);
        $256 = HEAP32[$255>>2]|0;
        $257 = ((($256)) + 12|0);
        HEAP32[$257>>2] = $$1;
        HEAP32[$255>>2] = $$1;
        $258 = ((($$1)) + 8|0);
        HEAP32[$258>>2] = $256;
        $259 = ((($$1)) + 12|0);
        HEAP32[$259>>2] = $$0349;
        $260 = ((($$1)) + 24|0);
        HEAP32[$260>>2] = 0;
        break;
       }
      }
     } while(0);
     $261 = HEAP32[(136028)>>2]|0;
     $262 = (($261) + -1)|0;
     HEAP32[(136028)>>2] = $262;
     $263 = ($262|0)==(0);
     if ($263) {
      $$0195$in$i = (136480);
      while(1) {
       $$0195$i = HEAP32[$$0195$in$i>>2]|0;
       $264 = ($$0195$i|0)==(0|0);
       $265 = ((($$0195$i)) + 8|0);
       if ($264) {
        break;
       } else {
        $$0195$in$i = $265;
       }
      }
      HEAP32[(136028)>>2] = -1;
     }
    }
   }
  }
 } while(0);
 $266 = HEAP32[(136440)>>2]|0;
 $267 = $266 & 2;
 $268 = ($267|0)==(0);
 if ($268) {
  return;
 }
 (___pthread_mutex_unlock((136444))|0);
 return;
}
function _sbrk(increment) {
    increment = increment|0;
    var oldDynamicTop = 0;
    var oldDynamicTopOnChange = 0;
    var newDynamicTop = 0;
    var totalMemory = 0;
    increment = ((increment + 15) & -16)|0;
    totalMemory = getTotalMemory()|0;

    // Perform a compare-and-swap loop to update the new dynamic top value. This is because
    // this function can becalled simultaneously in multiple threads.
    do {
      oldDynamicTop = Atomics_load(HEAP32, DYNAMICTOP_PTR>>2)|0;
      newDynamicTop = oldDynamicTop + increment | 0;
      // Asking to increase dynamic top to a too high value? In pthreads builds we cannot
      // enlarge memory, so this needs to fail.
      if (((increment|0) > 0 & (newDynamicTop|0) < (oldDynamicTop|0)) // Detect and fail if we would wrap around signed 32-bit int.
        | (newDynamicTop|0) < 0 // Also underflow, sbrk() should be able to be used to subtract.
        | (newDynamicTop|0) > (totalMemory|0)) {
        abortOnCannotGrowMemory()|0;
      }
      // Attempt to update the dynamic top to new value. Another thread may have beat this thread to the update,
      // in which case we will need to start over by iterating the loop body again.
      oldDynamicTopOnChange = Atomics_compareExchange(HEAP32, DYNAMICTOP_PTR>>2, oldDynamicTop|0, newDynamicTop|0)|0;
    } while((oldDynamicTopOnChange|0) != (oldDynamicTop|0));
    return oldDynamicTop|0;
}
function ___pthread_mutex_lock($0) {
 $0 = $0|0;
 var $$0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = HEAP32[$0>>2]|0;
 $2 = $1 & 15;
 $3 = ($2|0)==(0);
 if ($3) {
  $4 = ((($0)) + 4|0);
  $5 = (Atomics_compareExchange(HEAP32, $4>>2,0,16)|0);
  $6 = ($5|0)==(0);
  if ($6) {
   $$0 = 0;
   return ($$0|0);
  }
 }
 $7 = (___pthread_mutex_timedlock($0,0)|0);
 $$0 = $7;
 return ($$0|0);
}
function ___pthread_mutex_unlock($0) {
 $0 = $0|0;
 var $$0 = 0, $$045 = 0, $$pre = 0, $$pre$phiZ2D = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 var $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0;
 var $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = ((($0)) + 8|0);
 $2 = (Atomics_load(HEAP32,$1>>2)|0);
 $3 = HEAP32[$0>>2]|0;
 $4 = $3 & 15;
 $5 = $3 & 128;
 $6 = $5 ^ 128;
 $7 = ($4|0)==(0);
 if ($7) {
  $$pre = ((($0)) + 4|0);
  $$045 = 0;$$pre$phiZ2D = $$pre;
 } else {
  $8 = (_pthread_self()|0);
  $9 = ((($0)) + 4|0);
  $10 = (Atomics_load(HEAP32,$9>>2)|0);
  $11 = $10 & 2147483647;
  $12 = ((($8)) + 52|0);
  $13 = HEAP32[$12>>2]|0;
  $14 = ($11|0)==($13|0);
  if (!($14)) {
   $$0 = 1;
   return ($$0|0);
  }
  $15 = $3 & 3;
  $16 = ($15|0)==(1);
  if ($16) {
   $17 = ((($0)) + 20|0);
   $18 = HEAP32[$17>>2]|0;
   $19 = ($18|0)==(0);
   if (!($19)) {
    $20 = (($18) + -1)|0;
    HEAP32[$17>>2] = $20;
    $$0 = 0;
    return ($$0|0);
   }
  }
  $21 = ($6|0)==(0);
  $22 = ((($0)) + 16|0);
  if ($21) {
   $23 = ((($8)) + 176|0);
   Atomics_store(HEAP32,$23>>2,$22)|0;
   ___vm_lock();
  }
  $24 = ((($0)) + 12|0);
  $25 = HEAP32[$24>>2]|0;
  $26 = HEAP32[$22>>2]|0;
  Atomics_store(HEAP32,$25>>2,$26)|0;
  $27 = ((($8)) + 168|0);
  $28 = ($26|0)==($27|0);
  if ($28) {
   $$045 = $8;$$pre$phiZ2D = $9;
  } else {
   $29 = ((($26)) + -4|0);
   Atomics_store(HEAP32,$29>>2,$25)|0;
   $$045 = $8;$$pre$phiZ2D = $9;
  }
 }
 $30 = $3 & 8;
 $31 = ($30|0)!=(0);
 $32 = $31 ? 2147483647 : 0;
 while(1) {
  $33 = (Atomics_load(HEAP32, $$pre$phiZ2D>>2)|0);
  $34 = (Atomics_compareExchange(HEAP32, $$pre$phiZ2D>>2,$33,$32)|0);
  $35 = ($34|0)==($33|0);
  if ($35) {
   break;
  }
 }
 $36 = ($6|0)!=(0);
 $or$cond = $7 | $36;
 if (!($or$cond)) {
  $37 = ((($$045)) + 176|0);
  Atomics_store(HEAP32,$37>>2,0)|0;
  ___vm_unlock();
 }
 $38 = ($2|0)!=(0);
 $39 = ($33|0)<(0);
 $or$cond3 = $38 | $39;
 if (!($or$cond3)) {
  $$0 = 0;
  return ($$0|0);
 }
 (_emscripten_futex_wake(($$pre$phiZ2D|0),1)|0);
 $$0 = 0;
 return ($$0|0);
}
var Fetch = {
  attr_t_offset_requestMethod: 0,
  attr_t_offset_userData: 32,
  attr_t_offset_onsuccess: 36,
  attr_t_offset_onerror: 40,
  attr_t_offset_onprogress: 44,
  attr_t_offset_attributes: 48,
  attr_t_offset_timeoutMSecs: 52,
  attr_t_offset_withCredentials: 56,
  attr_t_offset_destinationPath: 60,
  attr_t_offset_userName: 64,
  attr_t_offset_password: 68,
  attr_t_offset_requestHeaders: 72,
  attr_t_offset_overriddenMimeType: 76,
  attr_t_offset_requestData: 80,
  attr_t_offset_requestDataSize: 84,

  fetch_t_offset_id: 0,
  fetch_t_offset_userData: 4,
  fetch_t_offset_url: 8,
  fetch_t_offset_data: 12,
  fetch_t_offset_numBytes: 16,
  fetch_t_offset_dataOffset: 24,
  fetch_t_offset_totalBytes: 32,
  fetch_t_offset_readyState: 40,
  fetch_t_offset_status: 42,
  fetch_t_offset_statusText: 44,
  fetch_t_offset___proxyState: 108,
  fetch_t_offset___attributes: 112,

  xhrs: [],
  // The web worker that runs proxied file I/O requests.
  worker: undefined,
  // Specifies an instance to the IndexedDB database. The database is opened
  // as a preload step before the Emscripten application starts.
  dbInstance: undefined,

  setu64: function(addr, val) {
    HEAPU32[addr >> 2] = val;
    HEAPU32[addr + 4 >> 2] = (val / 4294967296)|0;
  },

  openDatabase: function(dbname, dbversion, onsuccess, onerror) {
    try {

      console.log('fetch: indexedDB.open(dbname="' + dbname + '", dbversion="' + dbversion + '");');

      var openRequest = indexedDB.open(dbname, dbversion);
    } catch (e) { return onerror(e); }

    openRequest.onupgradeneeded = function(event) {

      console.log('fetch: IndexedDB upgrade needed. Clearing database.');

      var db = event.target.result;
      if (db.objectStoreNames.contains('FILES')) {
        db.deleteObjectStore('FILES');
      }
      db.createObjectStore('FILES');
    };
    openRequest.onsuccess = function(event) { onsuccess(event.target.result); };
    openRequest.onerror = function(error) { onerror(error); };
  },

  initFetchWorker: function() {
    var stackSize = 128*1024;
    var stack = allocate(stackSize>>2, "i32*", ALLOC_DYNAMIC);
    Fetch.worker.postMessage({cmd: 'init', TOTAL_MEMORY: TOTAL_MEMORY, DYNAMICTOP_PTR: DYNAMICTOP_PTR, STACKTOP: stack, STACK_MAX: stack + stackSize, queuePtr: _fetch_work_queue, buffer: HEAPU8.buffer});
  },

  staticInit: function() {



    var isMainThread = (typeof ENVIRONMENT_IS_FETCH_WORKER === 'undefined');


    var onsuccess = function(db) {

      console.log('fetch: IndexedDB successfully opened.');

      Fetch.dbInstance = db;







      if (typeof ENVIRONMENT_IS_FETCH_WORKER === 'undefined' || !ENVIRONMENT_IS_FETCH_WORKER) removeRunDependency('library_fetch_init');

    };
    var onerror = function() {

      console.error('fetch: IndexedDB open failed.');

      Fetch.dbInstance = false;







    };
    Fetch.openDatabase('emscripten_filesystem', 1, onsuccess, onerror);
    if (typeof ENVIRONMENT_IS_FETCH_WORKER === 'undefined' || !ENVIRONMENT_IS_FETCH_WORKER) addRunDependency('library_fetch_init');

  }
}

function __emscripten_fetch_delete_cached_data(db, fetch, onsuccess, onerror) {
  if (!db) {

    console.error('fetch: IndexedDB not available!');

    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var path = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  if (!path) path = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  var pathStr = Pointer_stringify(path);

  try {
    var transaction = db.transaction(['FILES'], 'readwrite');
    var packages = transaction.objectStore('FILES');
    var request = packages.delete(pathStr);
    request.onsuccess = function(event) {
      var value = event.target.result;

      console.log('fetch: Deleted file ' + pathStr + ' from IndexedDB');

      HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = 0;
      Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, 0);
      Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
      Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
      stringToUTF8("OK", fetch + Fetch.fetch_t_offset_statusText, 64);
      onsuccess(fetch, 0, value);
    };
    request.onerror = function(error) {

      console.error('fetch: Failed to delete file ' + pathStr + ' from IndexedDB! error: ' + error);

      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
      stringToUTF8("Not Found", fetch + Fetch.fetch_t_offset_statusText, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {

    console.error('fetch: Failed to load file ' + pathStr + ' from IndexedDB! Got exception ' + e);

    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_load_cached_data(db, fetch, onsuccess, onerror) {
  if (!db) {

    console.error('fetch: IndexedDB not available!');

    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var path = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  if (!path) path = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  var pathStr = Pointer_stringify(path);

  try {
    var transaction = db.transaction(['FILES'], 'readonly');
    var packages = transaction.objectStore('FILES');
    var getRequest = packages.get(pathStr);
    getRequest.onsuccess = function(event) {
      if (event.target.result) {
        var value = event.target.result;
        var len = value.byteLength || value.length;

        console.log('fetch: Loaded file ' + pathStr + ' from IndexedDB, length: ' + len);


        // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
        // freed when emscripten_fetch_close() is called.
        var ptr = _malloc(len);
        HEAPU8.set(new Uint8Array(value), ptr);
        HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = ptr;
        Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, len);
        Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
        Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, len);
        HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
        stringToUTF8("OK", fetch + Fetch.fetch_t_offset_statusText, 64);
        onsuccess(fetch, 0, value);
      } else {
        // Succeeded to load, but the load came back with the value of undefined, treat that as an error since we never store undefined in db.

        console.error('fetch: File ' + pathStr + ' not found in IndexedDB');

        HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
        stringToUTF8("Not Found", fetch + Fetch.fetch_t_offset_statusText, 64);
        onerror(fetch, 0, 'no data');
      }
    };
    getRequest.onerror = function(error) {

      console.error('fetch: Failed to load file ' + pathStr + ' from IndexedDB!');

      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
      stringToUTF8("Not Found", fetch + Fetch.fetch_t_offset_statusText, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {

    console.error('fetch: Failed to load file ' + pathStr + ' from IndexedDB! Got exception ' + e);

    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_cache_data(db, fetch, data, onsuccess, onerror) {
  if (!db) {

    console.error('fetch: IndexedDB not available!');

    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var destinationPath = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  if (!destinationPath) destinationPath = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  var destinationPathStr = Pointer_stringify(destinationPath);

  try {
    var transaction = db.transaction(['FILES'], 'readwrite');
    var packages = transaction.objectStore('FILES');
    var putRequest = packages.put(data, destinationPathStr);
    putRequest.onsuccess = function(event) {

      console.log('fetch: Stored file "' + destinationPathStr + '" to IndexedDB cache.');

      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
      stringToUTF8("OK", fetch + Fetch.fetch_t_offset_statusText, 64);
      onsuccess(fetch, 0, destinationPathStr);
    };
    putRequest.onerror = function(error) {

      console.error('fetch: Failed to store file "' + destinationPathStr + '" to IndexedDB cache!');

      // Most likely we got an error if IndexedDB is unwilling to store any more data for this page.
      // TODO: Can we identify and break down different IndexedDB-provided errors and convert those
      // to more HTTP status codes for more information?
      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 413; // Mimic XHR HTTP status code 413 "Payload Too Large"
      stringToUTF8("Payload Too Large", fetch + Fetch.fetch_t_offset_statusText, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {

      console.error('fetch: Failed to store file "' + destinationPathStr + '" to IndexedDB cache! Exception: ' + e);

    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_xhr(fetch, onsuccess, onerror, onprogress) {
  var url = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  if (!url) {

    console.error('fetch: XHR failed, no URL specified!');

    onerror(fetch, 0, 'no url specified!');
    return;
  }
  var url_ = Pointer_stringify(url);

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var requestMethod = Pointer_stringify(fetch_attr);
  if (!requestMethod) requestMethod = 'GET';
  var userData = HEAPU32[fetch_attr + Fetch.attr_t_offset_userData >> 2];
  var fetchAttributes = HEAPU32[fetch_attr + Fetch.attr_t_offset_attributes >> 2];
  var timeoutMsecs = HEAPU32[fetch_attr + Fetch.attr_t_offset_timeoutMSecs >> 2];
  var withCredentials = !!HEAPU32[fetch_attr + Fetch.attr_t_offset_withCredentials >> 2];
  var destinationPath = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  var userName = HEAPU32[fetch_attr + Fetch.attr_t_offset_userName >> 2];
  var password = HEAPU32[fetch_attr + Fetch.attr_t_offset_password >> 2];
  var requestHeaders = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestHeaders >> 2];
  var overriddenMimeType = HEAPU32[fetch_attr + Fetch.attr_t_offset_overriddenMimeType >> 2];
  var dataPtr = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestData >> 2];
  var dataLength = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestDataSize >> 2];

  var fetchAttrLoadToMemory = !!(fetchAttributes & 1/*EMSCRIPTEN_FETCH_LOAD_TO_MEMORY*/);
  var fetchAttrStreamData = !!(fetchAttributes & 2/*EMSCRIPTEN_FETCH_STREAM_DATA*/);
  var fetchAttrPersistFile = !!(fetchAttributes & 4/*EMSCRIPTEN_FETCH_PERSIST_FILE*/);
  var fetchAttrAppend = !!(fetchAttributes & 8/*EMSCRIPTEN_FETCH_APPEND*/);
  var fetchAttrReplace = !!(fetchAttributes & 16/*EMSCRIPTEN_FETCH_REPLACE*/);
  var fetchAttrNoDownload = !!(fetchAttributes & 32/*EMSCRIPTEN_FETCH_NO_DOWNLOAD*/);
  var fetchAttrSynchronous = !!(fetchAttributes & 64/*EMSCRIPTEN_FETCH_SYNCHRONOUS*/);
  var fetchAttrWaitable = !!(fetchAttributes & 128/*EMSCRIPTEN_FETCH_WAITABLE*/);

  var userNameStr = userName ? Pointer_stringify(userName) : undefined;
  var passwordStr = password ? Pointer_stringify(password) : undefined;
  var overriddenMimeTypeStr = overriddenMimeType ? Pointer_stringify(overriddenMimeType) : undefined;

  var xhr = new XMLHttpRequest();
  xhr.withCredentials = withCredentials;

  console.log('fetch: xhr.timeout: ' + xhr.timeout + ', xhr.withCredentials: ' + xhr.withCredentials);
  console.log('fetch: xhr.open(requestMethod="' + requestMethod + '", url: "' + url_ +'", userName: ' + userNameStr + ', password: ' + passwordStr + ');');

  xhr.open(requestMethod, url_, !fetchAttrSynchronous, userNameStr, passwordStr);
  if (!fetchAttrSynchronous) xhr.timeout = timeoutMsecs; // XHR timeout field is only accessible in async XHRs, and must be set after .open() but before .send().
  xhr.url_ = url_; // Save the url for debugging purposes (and for comparing to the responseURL that server side advertised)
  xhr.responseType = fetchAttrStreamData ? 'moz-chunked-arraybuffer' : 'arraybuffer';

  if (overriddenMimeType) {

    console.log('fetch: xhr.overrideMimeType("' + overriddenMimeTypeStr + '");');

    xhr.overrideMimeType(overriddenMimeTypeStr);
  }
  if (requestHeaders) {
    for(;;) {
      var key = HEAPU32[requestHeaders >> 2];
      if (!key) break;
      var value = HEAPU32[requestHeaders + 4 >> 2];
      if (!value) break;
      requestHeaders += 8;
      var keyStr = Pointer_stringify(key);
      var valueStr = Pointer_stringify(value);

      console.log('fetch: xhr.setRequestHeader("' + keyStr + '", "' + valueStr + '");');

      xhr.setRequestHeader(keyStr, valueStr);
    }
  }
  Fetch.xhrs.push(xhr);
  var id = Fetch.xhrs.length;
  HEAPU32[fetch + Fetch.fetch_t_offset_id >> 2] = id;
  var data = (dataPtr && dataLength) ? HEAPU8.slice(dataPtr, dataPtr + dataLength) : null;
  // TODO: Support specifying custom headers to the request.

  xhr.onload = function(e) {
    var len = xhr.response ? xhr.response.byteLength : 0;
    var ptr = 0;
    var ptrLen = 0;
    if (fetchAttrLoadToMemory && !fetchAttrStreamData) {
      ptrLen = len;

      console.log('fetch: allocating ' + ptrLen + ' bytes in Emscripten heap for xhr data');

      // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
      // freed when emscripten_fetch_close() is called.
      ptr = _malloc(ptrLen);
      HEAPU8.set(new Uint8Array(xhr.response), ptr);
    }
    HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = ptr;
    Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, ptrLen);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
    if (len) {
      // If the final XHR.onload handler receives the bytedata to compute total length, report that,
      // otherwise don't write anything out here, which will retain the latest byte size reported in
      // the most recent XHR.onprogress handler.
      Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, len);
    }
    HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = xhr.readyState;
    if (xhr.readyState === 4 && xhr.status === 0) {
      if (len > 0) xhr.status = 200; // If loading files from a source that does not give HTTP status code, assume success if we got data bytes.
      else xhr.status = 404; // Conversely, no data bytes is 404.
    }
    HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = xhr.status;
    if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + Fetch.fetch_t_offset_statusText, 64);
    if (xhr.status == 200) {

      console.log('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" succeeded with status 200');

      if (onsuccess) onsuccess(fetch, xhr, e);
    } else {

      console.error('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" failed with status ' + xhr.status);

      if (onerror) onerror(fetch, xhr, e);
    }
  }
  xhr.onerror = function(e) {
    var status = xhr.status; // XXX TODO: Overwriting xhr.status doesn't work here, so don't override anywhere else either.
    if (xhr.readyState == 4 && status == 0) status = 404; // If no error recorded, pretend it was 404 Not Found.

    console.error('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" finished with error, readyState ' + xhr.readyState + ' and status ' + status);

    HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = 0;
    Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, 0);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, 0);
    HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = xhr.readyState;
    HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = status;
    if (onerror) onerror(fetch, xhr, e);
  }
  xhr.ontimeout = function(e) {

    console.error('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" timed out, readyState ' + xhr.readyState + ' and status ' + xhr.status);

    if (onerror) onerror(fetch, xhr, e);
  }
  xhr.onprogress = function(e) {
    var ptrLen = (fetchAttrLoadToMemory && fetchAttrStreamData && xhr.response) ? xhr.response.byteLength : 0;
    var ptr = 0;
    if (fetchAttrLoadToMemory && fetchAttrStreamData) {

      console.log('fetch: allocating ' + ptrLen + ' bytes in Emscripten heap for xhr data');

      // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
      // freed when emscripten_fetch_close() is called.
      ptr = _malloc(ptrLen);
      HEAPU8.set(new Uint8Array(xhr.response), ptr);
    }
    HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = ptr;
    Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, ptrLen);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, e.loaded - ptrLen);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, e.total);
    HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = xhr.readyState;
    if (xhr.readyState >= 3 && xhr.status === 0 && e.loaded > 0) xhr.status = 200; // If loading files from a source that does not give HTTP status code, assume success if we get data bytes
    HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = xhr.status;
    if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + Fetch.fetch_t_offset_statusText, 64);
    if (onprogress) onprogress(fetch, xhr, e);
  }

  console.log('fetch: xhr.send(data=' + data + ')');

  try {
    xhr.send(data);
  } catch(e) {

    console.error('fetch: xhr failed with exception: ' + e);

    if (onerror) onerror(fetch, xhr, e);
  }
}

function emscripten_start_fetch(fetch, successcb, errorcb, progresscb) {
  if (typeof Module !== 'undefined') Module['noExitRuntime'] = true; // If we are the main Emscripten runtime, we should not be closing down.

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var requestMethod = Pointer_stringify(fetch_attr);
  var onsuccess = HEAPU32[fetch_attr + Fetch.attr_t_offset_onsuccess >> 2];
  var onerror = HEAPU32[fetch_attr + Fetch.attr_t_offset_onerror >> 2];
  var onprogress = HEAPU32[fetch_attr + Fetch.attr_t_offset_onprogress >> 2];
  var fetchAttributes = HEAPU32[fetch_attr + Fetch.attr_t_offset_attributes >> 2];
  var fetchAttrLoadToMemory = !!(fetchAttributes & 1/*EMSCRIPTEN_FETCH_LOAD_TO_MEMORY*/);
  var fetchAttrStreamData = !!(fetchAttributes & 2/*EMSCRIPTEN_FETCH_STREAM_DATA*/);
  var fetchAttrPersistFile = !!(fetchAttributes & 4/*EMSCRIPTEN_FETCH_PERSIST_FILE*/);
  var fetchAttrAppend = !!(fetchAttributes & 8/*EMSCRIPTEN_FETCH_APPEND*/);
  var fetchAttrReplace = !!(fetchAttributes & 16/*EMSCRIPTEN_FETCH_REPLACE*/);
  var fetchAttrNoDownload = !!(fetchAttributes & 32/*EMSCRIPTEN_FETCH_NO_DOWNLOAD*/);

  var reportSuccess = function(fetch, xhr, e) {

    console.log('fetch: operation success. e: ' + e);

    if (onsuccess && typeof dynCall === 'function') Module['dynCall_vi'](onsuccess, fetch);
    else if (successcb) successcb(fetch);
  };

  var cacheResultAndReportSuccess = function(fetch, xhr, e) {

    console.log('fetch: operation success. Caching result.. e: ' + e);

    var storeSuccess = function(fetch, xhr, e) {

      console.log('fetch: IndexedDB store succeeded.');

      if (onsuccess && typeof dynCall === 'function') Module['dynCall_vi'](onsuccess, fetch);
      else if (successcb) successcb(fetch);
    };
    var storeError = function(fetch, xhr, e) {

      console.error('fetch: IndexedDB store failed.');

      if (onsuccess && typeof dynCall === 'function') Module['dynCall_vi'](onsuccess, fetch);
      else if (successcb) successcb(fetch);
    };
    __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, xhr.response, storeSuccess, storeError);
  };

  var reportProgress = function(fetch, xhr, e) {
    if (onprogress && typeof dynCall === 'function') Module['dynCall_vi'](onprogress, fetch);
    else if (progresscb) progresscb(fetch);
  };

  var reportError = function(fetch, xhr, e) {

    console.error('fetch: operation failed: ' + e);

    if (onerror && typeof dynCall === 'function') Module['dynCall_vi'](onerror, fetch);
    else if (errorcb) errorcb(fetch);
  };

  var performUncachedXhr = function(fetch, xhr, e) {

    console.error('fetch: starting (uncached) XHR: ' + e);

    __emscripten_fetch_xhr(fetch, reportSuccess, reportError, reportProgress);
  };

  var performCachedXhr = function(fetch, xhr, e) {

    console.error('fetch: starting (cached) XHR: ' + e);

    __emscripten_fetch_xhr(fetch, cacheResultAndReportSuccess, reportError, reportProgress);
  };

  // Should we try IndexedDB first?
  if (!fetchAttrReplace || requestMethod === 'EM_IDB_STORE' || requestMethod === 'EM_IDB_DELETE') {
    if (!Fetch.dbInstance) {

      console.error('fetch: failed to read IndexedDB! Database is not open.');

      reportError(fetch, 0, 'IndexedDB is not open');
      return 0; // todo: free
    }

    if (requestMethod === 'EM_IDB_STORE') {
      var dataPtr = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestData >> 2];
      var dataLength = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestDataSize >> 2];
      var data = HEAPU8.slice(dataPtr, dataPtr + dataLength); // TODO(?): Here we perform a clone of the data, because storing shared typed arrays to IndexedDB does not seem to be allowed.
      __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, data, reportSuccess, reportError);
    } else if (requestMethod === 'EM_IDB_DELETE') {
      __emscripten_fetch_delete_cached_data(Fetch.dbInstance, fetch, reportSuccess, reportError);
    } else if (fetchAttrNoDownload) {
      __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, reportError);
    } else if (fetchAttrPersistFile) {
      __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, performCachedXhr);
    } else {
      __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, performUncachedXhr);
    }
  } else if (!fetchAttrNoDownload) {
    if (fetchAttrPersistFile) {
      __emscripten_fetch_xhr(fetch, cacheResultAndReportSuccess, reportError, reportProgress);
    } else {
      __emscripten_fetch_xhr(fetch, reportSuccess, reportError, reportProgress);
    }
  } else {

    console.error('fetch: Invalid combination of flags passed.');

    return 0; // todo: free
  }
  return fetch;
}

if (typeof Atomics === 'undefined') {
  // Polyfill singlethreaded atomics ops from http://lars-t-hansen.github.io/ecmascript_sharedmem/shmem.html#Atomics.add
  // No thread-safety needed since we don't have multithreading support.
  Atomics = {};
  Atomics['add'] = function(t, i, v) { var w = t[i]; t[i] += v; return w; }
  Atomics['and'] = function(t, i, v) { var w = t[i]; t[i] &= v; return w; }
  Atomics['compareExchange'] = function(t, i, e, r) { var w = t[i]; if (w == e) t[i] = r; return w; }
  Atomics['exchange'] = function(t, i, v) { var w = t[i]; t[i] = v; return w; }
  Atomics['wait'] = function(t, i, v, o) { if (t[i] != v) return 'not-equal'; else return 'timed-out'; }
  Atomics['wake'] = function(t, i, c) { return 0; }
  Atomics['wakeOrRequeue'] = function(t, i1, c, i2, v) { return 0; }
  Atomics['isLockFree'] = function(s) { return true; }
  Atomics['load'] = function(t, i) { return t[i]; }
  Atomics['or'] = function(t, i, v) { var w = t[i]; t[i] |= v; return w; }
  Atomics['store'] = function(t, i, v) { t[i] = v; return v; }
  Atomics['sub'] = function(t, i, v) { var w = t[i]; t[i] -= v; return w; }
  Atomics['xor'] = function(t, i, v) { var w = t[i]; t[i] ^= v; return w; }
}

var Atomics_add = Atomics.add;
var Atomics_and = Atomics.and;
var Atomics_compareExchange = Atomics.compareExchange;
var Atomics_exchange = Atomics.exchange;
var Atomics_wait = Atomics.wait;
var Atomics_wake = Atomics.wake;
var Atomics_wakeOrRequeue = Atomics.wakeOrRequeue;
var Atomics_isLockFree = Atomics.isLockFree;
var Atomics_load = Atomics.load;
var Atomics_or = Atomics.or;
var Atomics_store = Atomics.store;
var Atomics_sub = Atomics.sub;
var Atomics_xor = Atomics.xor;

var ENVIRONMENT_IS_FETCH_WORKER = true;
var ENVIRONMENT_IS_WORKER = true;
var ENVIRONMENT_IS_PTHREAD = true;
var __pthread_is_main_runtime_thread=0;
var DYNAMICTOP_PTR = 0;
var TOTAL_MEMORY = 0;
function enlargeMemory() {
  abort('Cannot enlarge memory arrays, since compiling with pthreads support enabled (-s USE_PTHREADS=1).');
}
var nan = NaN;
var inf = Infinity;

function _emscripten_asm_const_v() {}

function assert(condition) {
  if (!condition) console.error('assert failure!');
}

/// TODO: DO SOMETHING ABOUT ME.
function Pointer_stringify(ptr, /* optional */ length) {
  if (length === 0 || !ptr) return "";
  // TODO: use TextDecoder
  // Find the length, and check for UTF while doing so
  var hasUtf = 0;
  var t;
  var i = 0;
  while (1) {
    t = HEAPU8[(((ptr)+(i))>>0)];
    hasUtf |= t;
    if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;

  var ret = "";

  if (hasUtf < 128) {
    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
      ret = ret ? ret + curr : curr;
      ptr += MAX_CHUNK;
      length -= MAX_CHUNK;
    }
    return ret;
  }
  return Module['UTF8ToString'](ptr);
}

Fetch.staticInit();

var queuePtr = 0;
var buffer = null;
var STACKTOP = 0;
var STACK_MAX = 0;
var HEAP8 = null;
var HEAPU8 = null;
var HEAP16 = null;
var HEAPU16 = null;
var HEAP32 = null;
var HEAPU32 = null;

function processWorkQueue() {
  if (!queuePtr) return;
  var numQueuedItems = Atomics_load(HEAPU32, queuePtr + 4 >> 2);
  if (numQueuedItems == 0) return;

  var queuedOperations = Atomics_load(HEAPU32, queuePtr >> 2);
  var queueSize = Atomics_load(HEAPU32, queuePtr + 8 >> 2);
  for(var i = 0; i < numQueuedItems; ++i) {
    var fetch = Atomics_load(HEAPU32, (queuedOperations >> 2)+i);
    function successcb(fetch) {
      Atomics.compareExchange(HEAPU32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1, 2);
      Atomics.wake(HEAP32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1);
    }
    function errorcb(fetch) {
      Atomics.compareExchange(HEAPU32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1, 2);
      Atomics.wake(HEAP32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1);
    }
    function progresscb(fetch) {
    }
    try {
      emscripten_start_fetch(fetch, successcb, errorcb, progresscb);
    } catch(e) {
      console.error(e);
    }
    /*
    if (interval != undefined) {
      clearInterval(interval);
      interval = undefined;
    }
    */
  }
  Atomics_store(HEAPU32, queuePtr + 4 >> 2, 0);
}

interval = 0;
this.onmessage = function(e) {
  if (e.data.cmd == 'init') {
    queuePtr = e.data.queuePtr;
    buffer = e.data.buffer;
    STACKTOP = e.data.STACKTOP;
    STACK_MAX = e.data.STACK_MAX;
    DYNAMICTOP_PTR = e.data.DYNAMICTOP_PTR;
    TOTAL_MEMORY = e.data.TOTAL_MEMORY;
    HEAP8 = new Int8Array(buffer);
    HEAPU8 = new Uint8Array(buffer);
    HEAP16 = new Int16Array(buffer);
    HEAPU16 = new Uint16Array(buffer);
    HEAP32 = new Int32Array(buffer);
    HEAPU32 = new Uint32Array(buffer);
    interval = setInterval(processWorkQueue, 100);
  }
}
