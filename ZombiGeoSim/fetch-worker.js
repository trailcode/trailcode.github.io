this.onerror = function(e) {
  console.error(e);
}


function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}
function getTotalMemory() {
  return TOTAL_MEMORY;
}
function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      ++len;
    } else if (u <= 0x7FF) {
      len += 2;
    } else if (u <= 0xFFFF) {
      len += 3;
    } else if (u <= 0x1FFFFF) {
      len += 4;
    } else if (u <= 0x3FFFFFF) {
      len += 5;
    } else {
      len += 6;
    }
  }
  return len;
}
function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x1FFFFF) {
      if (outIdx + 3 >= endIdx) break;
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x3FFFFFF) {
      if (outIdx + 4 >= endIdx) break;
      outU8Array[outIdx++] = 0xF8 | (u >> 24);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 5 >= endIdx) break;
      outU8Array[outIdx++] = 0xFC | (u >> 30);
      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}
function _emscripten_is_main_runtime_thread() {
    return __pthread_is_main_runtime_thread|0; // Semantically the same as testing "!ENVIRONMENT_IS_PTHREAD" outside the asm.js scope
}
function _emscripten_futex_wait(addr, val, timeout) {
      if (addr <= 0 || addr > HEAP8.length || addr&3 != 0) return -22;
  //    dump('futex_wait addr:' + addr + ' by thread: ' + _pthread_self() + (ENVIRONMENT_IS_PTHREAD?'(pthread)':'') + '\n');
      if (ENVIRONMENT_IS_WORKER) {
        var ret = Atomics.wait(HEAP32, addr >> 2, val, timeout);
  //    dump('futex_wait done by thread: ' + _pthread_self() + (ENVIRONMENT_IS_PTHREAD?'(pthread)':'') + '\n');
        if (ret === 'timed-out') return -110;
        if (ret === 'not-equal') return -11;
        if (ret === 'ok') return 0;
        throw 'Atomics.wait returned an unexpected value ' + ret;
      } else {
        // Atomics.wait is not available in the main browser thread, so simulate it via busy spinning.
        var loadedVal = Atomics.load(HEAP32, addr >> 2);
        if (val != loadedVal) return -11;
  
        var tNow = performance.now();
        var tEnd = tNow + timeout;
  
  
        // Register globally which address the main thread is simulating to be waiting on. When zero, main thread is not waiting on anything,
        // and on nonzero, the contents of address pointed by __main_thread_futex_wait_address tell which address the main thread is simulating its wait on.
        Atomics.store(HEAP32, __main_thread_futex_wait_address >> 2, addr);
        var ourWaitAddress = addr; // We may recursively re-enter this function while processing queued calls, in which case we'll do a spurious wakeup of the older wait operation.
        while (addr == ourWaitAddress) {
          tNow = performance.now();
          if (tNow > tEnd) {
            return -110;
          }
          _emscripten_main_thread_process_queued_calls(); // We are performing a blocking loop here, so must pump any pthreads if they want to perform operations that are proxied.
          addr = Atomics.load(HEAP32, __main_thread_futex_wait_address >> 2); // Look for a worker thread waking us up.
        }
        return 0;
      }
    }
function _malloc($0) {
 $0 = $0|0;
 var $$$0192$i = 0, $$$0193$i = 0, $$$4230$i = 0, $$$4236$i = 0, $$$4351$i = 0, $$$i = 0, $$0$i$i = 0, $$0$i$i$i = 0, $$0$i17$i = 0, $$0189$i = 0, $$0192$lcssa$i = 0, $$01926$i = 0, $$0193$lcssa$i = 0, $$01935$i = 0, $$0198 = 0, $$0200 = 0, $$0206$i$i = 0, $$0207$i$i = 0, $$0211$i$i = 0, $$0212$i$i = 0;
 var $$024359$i = 0, $$0287$i$i = 0, $$0288$i$i = 0, $$0289$i$i = 0, $$0295$i$i = 0, $$0296$i$i = 0, $$0342$i = 0, $$0344$i = 0, $$0345$i = 0, $$0347$i = 0, $$0353$i = 0, $$0358$i = 0, $$0359$$i = 0, $$0359$i = 0, $$0361$i = 0, $$0362$i = 0, $$0368$i = 0, $$1 = 0, $$1196$i = 0, $$1198$i = 0;
 var $$124458$i = 0, $$1291$i$i = 0, $$1293$i$i = 0, $$1343$i = 0, $$1348$i = 0, $$1363$i = 0, $$1370$i = 0, $$1374$i = 0, $$2 = 0, $$2234243136$i = 0, $$2247$ph$i = 0, $$2253$ph$i = 0, $$2355$i = 0, $$3$i = 0, $$3$i$i = 0, $$3$i204 = 0, $$3229$i = 0, $$3235$i = 0, $$3350$i = 0, $$3372$i = 0;
 var $$4$lcssa$i = 0, $$4$ph$i = 0, $$414$i = 0, $$4230$i = 0, $$4236$i = 0, $$4351$lcssa$i = 0, $$435113$i = 0, $$4357$$4$i = 0, $$4357$ph$i = 0, $$435712$i = 0, $$7$i = 0, $$7239$i = 0, $$pre = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i18$i = 0, $$pre$i211 = 0, $$pre$phi$i$iZ2D = 0, $$pre$phi$i19$iZ2D = 0, $$pre$phi$i212Z2D = 0;
 var $$pre$phi$iZ2D = 0, $$pre$phi11$i$iZ2D = 0, $$pre$phiZ2D = 0, $$pre10$i$i = 0, $$sink1$i = 0, $$sink1$i$i = 0, $$sink14$i = 0, $$sink2$i = 0, $$sink2$i206 = 0, $$sink3$i = 0, $1 = 0, $10 = 0, $100 = 0, $1000 = 0, $1001 = 0, $1002 = 0, $1003 = 0, $1004 = 0, $1005 = 0, $1006 = 0;
 var $1007 = 0, $1008 = 0, $1009 = 0, $101 = 0, $1010 = 0, $1011 = 0, $1012 = 0, $1013 = 0, $1014 = 0, $1015 = 0, $1016 = 0, $1017 = 0, $1018 = 0, $1019 = 0, $102 = 0, $1020 = 0, $1021 = 0, $1022 = 0, $1023 = 0, $1024 = 0;
 var $1025 = 0, $1026 = 0, $1027 = 0, $1028 = 0, $1029 = 0, $103 = 0, $1030 = 0, $1031 = 0, $1032 = 0, $1033 = 0, $1034 = 0, $1035 = 0, $1036 = 0, $1037 = 0, $1038 = 0, $1039 = 0, $104 = 0, $1040 = 0, $1041 = 0, $1042 = 0;
 var $1043 = 0, $1044 = 0, $1045 = 0, $1046 = 0, $1047 = 0, $1048 = 0, $1049 = 0, $105 = 0, $1050 = 0, $1051 = 0, $1052 = 0, $1053 = 0, $1054 = 0, $1055 = 0, $1056 = 0, $1057 = 0, $1058 = 0, $1059 = 0, $106 = 0, $1060 = 0;
 var $1061 = 0, $1062 = 0, $1063 = 0, $1064 = 0, $1065 = 0, $1066 = 0, $1067 = 0, $1068 = 0, $1069 = 0, $107 = 0, $1070 = 0, $1071 = 0, $1072 = 0, $1073 = 0, $1074 = 0, $1075 = 0, $1076 = 0, $1077 = 0, $1078 = 0, $1079 = 0;
 var $108 = 0, $1080 = 0, $1081 = 0, $1082 = 0, $1083 = 0, $1084 = 0, $1085 = 0, $1086 = 0, $1087 = 0, $1088 = 0, $1089 = 0, $109 = 0, $1090 = 0, $1091 = 0, $1092 = 0, $1093 = 0, $1094 = 0, $11 = 0, $110 = 0, $111 = 0;
 var $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0;
 var $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0;
 var $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0;
 var $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0;
 var $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0;
 var $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0;
 var $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0;
 var $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0;
 var $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0;
 var $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0;
 var $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0;
 var $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0;
 var $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0;
 var $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0;
 var $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0;
 var $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0;
 var $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0;
 var $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0, $435 = 0, $436 = 0;
 var $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0;
 var $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0, $472 = 0;
 var $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0, $49 = 0, $490 = 0;
 var $491 = 0, $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0, $503 = 0, $504 = 0, $505 = 0, $506 = 0, $507 = 0, $508 = 0;
 var $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0, $526 = 0;
 var $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0, $539 = 0, $54 = 0, $540 = 0, $541 = 0, $542 = 0, $543 = 0, $544 = 0;
 var $545 = 0, $546 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0, $559 = 0, $56 = 0, $560 = 0, $561 = 0, $562 = 0;
 var $563 = 0, $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0, $569 = 0, $57 = 0, $570 = 0, $571 = 0, $572 = 0, $573 = 0, $574 = 0, $575 = 0, $576 = 0, $577 = 0, $578 = 0, $579 = 0, $58 = 0, $580 = 0;
 var $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0, $593 = 0, $594 = 0, $595 = 0, $596 = 0, $597 = 0, $598 = 0, $599 = 0;
 var $6 = 0, $60 = 0, $600 = 0, $601 = 0, $602 = 0, $603 = 0, $604 = 0, $605 = 0, $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0, $610 = 0, $611 = 0, $612 = 0, $613 = 0, $614 = 0, $615 = 0, $616 = 0;
 var $617 = 0, $618 = 0, $619 = 0, $62 = 0, $620 = 0, $621 = 0, $622 = 0, $623 = 0, $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0, $630 = 0, $631 = 0, $632 = 0, $633 = 0, $634 = 0;
 var $635 = 0, $636 = 0, $637 = 0, $638 = 0, $639 = 0, $64 = 0, $640 = 0, $641 = 0, $642 = 0, $643 = 0, $644 = 0, $645 = 0, $646 = 0, $647 = 0, $648 = 0, $649 = 0, $65 = 0, $650 = 0, $651 = 0, $652 = 0;
 var $653 = 0, $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0, $660 = 0, $661 = 0, $662 = 0, $663 = 0, $664 = 0, $665 = 0, $666 = 0, $667 = 0, $668 = 0, $669 = 0, $67 = 0, $670 = 0;
 var $671 = 0, $672 = 0, $673 = 0, $674 = 0, $675 = 0, $676 = 0, $677 = 0, $678 = 0, $679 = 0, $68 = 0, $680 = 0, $681 = 0, $682 = 0, $683 = 0, $684 = 0, $685 = 0, $686 = 0, $687 = 0, $688 = 0, $689 = 0;
 var $69 = 0, $690 = 0, $691 = 0, $692 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0, $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0, $700 = 0, $701 = 0, $702 = 0, $703 = 0, $704 = 0, $705 = 0, $706 = 0;
 var $707 = 0, $708 = 0, $709 = 0, $71 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $72 = 0, $720 = 0, $721 = 0, $722 = 0, $723 = 0, $724 = 0;
 var $725 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0, $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0, $737 = 0, $738 = 0, $739 = 0, $74 = 0, $740 = 0, $741 = 0, $742 = 0;
 var $743 = 0, $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0, $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0, $755 = 0, $756 = 0, $757 = 0, $758 = 0, $759 = 0, $76 = 0, $760 = 0;
 var $761 = 0, $762 = 0, $763 = 0, $764 = 0, $765 = 0, $766 = 0, $767 = 0, $768 = 0, $769 = 0, $77 = 0, $770 = 0, $771 = 0, $772 = 0, $773 = 0, $774 = 0, $775 = 0, $776 = 0, $777 = 0, $778 = 0, $779 = 0;
 var $78 = 0, $780 = 0, $781 = 0, $782 = 0, $783 = 0, $784 = 0, $785 = 0, $786 = 0, $787 = 0, $788 = 0, $789 = 0, $79 = 0, $790 = 0, $791 = 0, $792 = 0, $793 = 0, $794 = 0, $795 = 0, $796 = 0, $797 = 0;
 var $798 = 0, $799 = 0, $8 = 0, $80 = 0, $800 = 0, $801 = 0, $802 = 0, $803 = 0, $804 = 0, $805 = 0, $806 = 0, $807 = 0, $808 = 0, $809 = 0, $81 = 0, $810 = 0, $811 = 0, $812 = 0, $813 = 0, $814 = 0;
 var $815 = 0, $816 = 0, $817 = 0, $818 = 0, $819 = 0, $82 = 0, $820 = 0, $821 = 0, $822 = 0, $823 = 0, $824 = 0, $825 = 0, $826 = 0, $827 = 0, $828 = 0, $829 = 0, $83 = 0, $830 = 0, $831 = 0, $832 = 0;
 var $833 = 0, $834 = 0, $835 = 0, $836 = 0, $837 = 0, $838 = 0, $839 = 0, $84 = 0, $840 = 0, $841 = 0, $842 = 0, $843 = 0, $844 = 0, $845 = 0, $846 = 0, $847 = 0, $848 = 0, $849 = 0, $85 = 0, $850 = 0;
 var $851 = 0, $852 = 0, $853 = 0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0, $859 = 0, $86 = 0, $860 = 0, $861 = 0, $862 = 0, $863 = 0, $864 = 0, $865 = 0, $866 = 0, $867 = 0, $868 = 0, $869 = 0;
 var $87 = 0, $870 = 0, $871 = 0, $872 = 0, $873 = 0, $874 = 0, $875 = 0, $876 = 0, $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0, $881 = 0, $882 = 0, $883 = 0, $884 = 0, $885 = 0, $886 = 0, $887 = 0;
 var $888 = 0, $889 = 0, $89 = 0, $890 = 0, $891 = 0, $892 = 0, $893 = 0, $894 = 0, $895 = 0, $896 = 0, $897 = 0, $898 = 0, $899 = 0, $9 = 0, $90 = 0, $900 = 0, $901 = 0, $902 = 0, $903 = 0, $904 = 0;
 var $905 = 0, $906 = 0, $907 = 0, $908 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0, $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0, $917 = 0, $918 = 0, $919 = 0, $92 = 0, $920 = 0, $921 = 0, $922 = 0;
 var $923 = 0, $924 = 0, $925 = 0, $926 = 0, $927 = 0, $928 = 0, $929 = 0, $93 = 0, $930 = 0, $931 = 0, $932 = 0, $933 = 0, $934 = 0, $935 = 0, $936 = 0, $937 = 0, $938 = 0, $939 = 0, $94 = 0, $940 = 0;
 var $941 = 0, $942 = 0, $943 = 0, $944 = 0, $945 = 0, $946 = 0, $947 = 0, $948 = 0, $949 = 0, $95 = 0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0, $955 = 0, $956 = 0, $957 = 0, $958 = 0, $959 = 0;
 var $96 = 0, $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0, $966 = 0, $967 = 0, $968 = 0, $969 = 0, $97 = 0, $970 = 0, $971 = 0, $972 = 0, $973 = 0, $974 = 0, $975 = 0, $976 = 0, $977 = 0;
 var $978 = 0, $979 = 0, $98 = 0, $980 = 0, $981 = 0, $982 = 0, $983 = 0, $984 = 0, $985 = 0, $986 = 0, $987 = 0, $988 = 0, $989 = 0, $99 = 0, $990 = 0, $991 = 0, $992 = 0, $993 = 0, $994 = 0, $995 = 0;
 var $996 = 0, $997 = 0, $998 = 0, $999 = 0, $cond$i = 0, $cond$i$i = 0, $cond$i210 = 0, $not$7$i = 0, $or$cond$i = 0, $or$cond$i213 = 0, $or$cond1$i = 0, $or$cond10$i = 0, $or$cond11$i = 0, $or$cond12$i = 0, $or$cond2$i = 0, $or$cond2$i214 = 0, $or$cond42$i = 0, $or$cond5$i = 0, $or$cond7$i = 0, $or$cond9$i = 0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abortStackOverflow(16|0);
 $1 = sp + 12|0;
 $2 = sp + 8|0;
 $3 = sp + 4|0;
 $4 = sp;
 $5 = HEAP32[44332]|0;
 $6 = ($5|0)==(0);
 if ($6) {
  (___pthread_mutex_lock(177352)|0);
  $7 = HEAP32[44332]|0;
  $8 = ($7|0)==(0);
  if ($8) {
   HEAP32[(177336)>>2] = 4096;
   HEAP32[(177332)>>2] = 4096;
   HEAP32[(177340)>>2] = -1;
   HEAP32[(177344)>>2] = -1;
   HEAP32[(177348)>>2] = 2;
   HEAP32[(177824)>>2] = 2;
   $9 = (_pthread_mutexattr_init($3)|0);
   $10 = ($9|0)==(0);
   if ($10) {
    $11 = (_pthread_mutex_init((177828),$3)|0);
    $12 = ($11|0)==(0);
    if ($12) {
    }
   }
   $13 = $4;
   $14 = $13 & -16;
   $15 = $14 ^ 1431655768;
   Atomics_store(HEAP32,44332,$15)|0;
  }
  (___pthread_mutex_unlock(177352)|0);
 }
 $16 = HEAP32[(177824)>>2]|0;
 $17 = $16 & 2;
 $18 = ($17|0)==(0);
 if (!($18)) {
  $19 = (___pthread_mutex_lock((177828))|0);
  $20 = ($19|0)==(0);
  if (!($20)) {
   $$1 = 0;
   STACKTOP = sp;return ($$1|0);
  }
 }
 $21 = ($0>>>0)<(245);
 do {
  if ($21) {
   $22 = ($0>>>0)<(11);
   $23 = (($0) + 11)|0;
   $24 = $23 & -8;
   $25 = $22 ? 16 : $24;
   $26 = $25 >>> 3;
   $27 = HEAP32[44345]|0;
   $28 = $27 >>> $26;
   $29 = $28 & 3;
   $30 = ($29|0)==(0);
   if (!($30)) {
    $31 = $28 & 1;
    $32 = $31 ^ 1;
    $33 = (($32) + ($26))|0;
    $34 = $33 << 1;
    $35 = (177420 + ($34<<2)|0);
    $36 = ((($35)) + 8|0);
    $37 = HEAP32[$36>>2]|0;
    $38 = ((($37)) + 8|0);
    $39 = HEAP32[$38>>2]|0;
    $40 = ($39|0)==($35|0);
    do {
     if ($40) {
      $41 = 1 << $33;
      $42 = $41 ^ -1;
      $43 = $27 & $42;
      HEAP32[44345] = $43;
     } else {
      $44 = HEAP32[(177396)>>2]|0;
      $45 = ($44>>>0)>($39>>>0);
      if ($45) {
       _abort();
       // unreachable;
      }
      $46 = ((($39)) + 12|0);
      $47 = HEAP32[$46>>2]|0;
      $48 = ($47|0)==($37|0);
      if ($48) {
       HEAP32[$46>>2] = $35;
       HEAP32[$36>>2] = $39;
       break;
      } else {
       _abort();
       // unreachable;
      }
     }
    } while(0);
    $49 = $33 << 3;
    $50 = $49 | 3;
    $51 = ((($37)) + 4|0);
    HEAP32[$51>>2] = $50;
    $52 = (($37) + ($49)|0);
    $53 = ((($52)) + 4|0);
    $54 = HEAP32[$53>>2]|0;
    $55 = $54 | 1;
    HEAP32[$53>>2] = $55;
    $$2 = $38;
    break;
   }
   $56 = HEAP32[(177388)>>2]|0;
   $57 = ($25>>>0)>($56>>>0);
   if ($57) {
    $58 = ($28|0)==(0);
    if (!($58)) {
     $59 = $28 << $26;
     $60 = 2 << $26;
     $61 = (0 - ($60))|0;
     $62 = $60 | $61;
     $63 = $59 & $62;
     $64 = (0 - ($63))|0;
     $65 = $63 & $64;
     $66 = (($65) + -1)|0;
     $67 = $66 >>> 12;
     $68 = $67 & 16;
     $69 = $66 >>> $68;
     $70 = $69 >>> 5;
     $71 = $70 & 8;
     $72 = $71 | $68;
     $73 = $69 >>> $71;
     $74 = $73 >>> 2;
     $75 = $74 & 4;
     $76 = $72 | $75;
     $77 = $73 >>> $75;
     $78 = $77 >>> 1;
     $79 = $78 & 2;
     $80 = $76 | $79;
     $81 = $77 >>> $79;
     $82 = $81 >>> 1;
     $83 = $82 & 1;
     $84 = $80 | $83;
     $85 = $81 >>> $83;
     $86 = (($84) + ($85))|0;
     $87 = $86 << 1;
     $88 = (177420 + ($87<<2)|0);
     $89 = ((($88)) + 8|0);
     $90 = HEAP32[$89>>2]|0;
     $91 = ((($90)) + 8|0);
     $92 = HEAP32[$91>>2]|0;
     $93 = ($92|0)==($88|0);
     do {
      if ($93) {
       $94 = 1 << $86;
       $95 = $94 ^ -1;
       $96 = $27 & $95;
       HEAP32[44345] = $96;
       $117 = $96;
      } else {
       $97 = HEAP32[(177396)>>2]|0;
       $98 = ($97>>>0)>($92>>>0);
       if ($98) {
        _abort();
        // unreachable;
       }
       $99 = ((($92)) + 12|0);
       $100 = HEAP32[$99>>2]|0;
       $101 = ($100|0)==($90|0);
       if ($101) {
        HEAP32[$99>>2] = $88;
        HEAP32[$89>>2] = $92;
        $117 = $27;
        break;
       } else {
        _abort();
        // unreachable;
       }
      }
     } while(0);
     $102 = $86 << 3;
     $103 = (($102) - ($25))|0;
     $104 = $25 | 3;
     $105 = ((($90)) + 4|0);
     HEAP32[$105>>2] = $104;
     $106 = (($90) + ($25)|0);
     $107 = $103 | 1;
     $108 = ((($106)) + 4|0);
     HEAP32[$108>>2] = $107;
     $109 = (($90) + ($102)|0);
     HEAP32[$109>>2] = $103;
     $110 = ($56|0)==(0);
     if (!($110)) {
      $111 = HEAP32[(177400)>>2]|0;
      $112 = $56 >>> 3;
      $113 = $112 << 1;
      $114 = (177420 + ($113<<2)|0);
      $115 = 1 << $112;
      $116 = $117 & $115;
      $118 = ($116|0)==(0);
      if ($118) {
       $119 = $117 | $115;
       HEAP32[44345] = $119;
       $$pre = ((($114)) + 8|0);
       $$0200 = $114;$$pre$phiZ2D = $$pre;
      } else {
       $120 = ((($114)) + 8|0);
       $121 = HEAP32[$120>>2]|0;
       $122 = HEAP32[(177396)>>2]|0;
       $123 = ($122>>>0)>($121>>>0);
       if ($123) {
        _abort();
        // unreachable;
       } else {
        $$0200 = $121;$$pre$phiZ2D = $120;
       }
      }
      HEAP32[$$pre$phiZ2D>>2] = $111;
      $124 = ((($$0200)) + 12|0);
      HEAP32[$124>>2] = $111;
      $125 = ((($111)) + 8|0);
      HEAP32[$125>>2] = $$0200;
      $126 = ((($111)) + 12|0);
      HEAP32[$126>>2] = $114;
     }
     HEAP32[(177388)>>2] = $103;
     HEAP32[(177400)>>2] = $106;
     $$2 = $91;
     break;
    }
    $127 = HEAP32[(177384)>>2]|0;
    $128 = ($127|0)==(0);
    if ($128) {
     $$0198 = $25;
     label = 153;
    } else {
     $129 = (0 - ($127))|0;
     $130 = $127 & $129;
     $131 = (($130) + -1)|0;
     $132 = $131 >>> 12;
     $133 = $132 & 16;
     $134 = $131 >>> $133;
     $135 = $134 >>> 5;
     $136 = $135 & 8;
     $137 = $136 | $133;
     $138 = $134 >>> $136;
     $139 = $138 >>> 2;
     $140 = $139 & 4;
     $141 = $137 | $140;
     $142 = $138 >>> $140;
     $143 = $142 >>> 1;
     $144 = $143 & 2;
     $145 = $141 | $144;
     $146 = $142 >>> $144;
     $147 = $146 >>> 1;
     $148 = $147 & 1;
     $149 = $145 | $148;
     $150 = $146 >>> $148;
     $151 = (($149) + ($150))|0;
     $152 = (177684 + ($151<<2)|0);
     $153 = HEAP32[$152>>2]|0;
     $154 = ((($153)) + 4|0);
     $155 = HEAP32[$154>>2]|0;
     $156 = $155 & -8;
     $157 = (($156) - ($25))|0;
     $158 = ((($153)) + 16|0);
     $159 = HEAP32[$158>>2]|0;
     $160 = ($159|0)==(0|0);
     $$sink14$i = $160&1;
     $161 = (((($153)) + 16|0) + ($$sink14$i<<2)|0);
     $162 = HEAP32[$161>>2]|0;
     $163 = ($162|0)==(0|0);
     if ($163) {
      $$0192$lcssa$i = $153;$$0193$lcssa$i = $157;
     } else {
      $$01926$i = $153;$$01935$i = $157;$165 = $162;
      while(1) {
       $164 = ((($165)) + 4|0);
       $166 = HEAP32[$164>>2]|0;
       $167 = $166 & -8;
       $168 = (($167) - ($25))|0;
       $169 = ($168>>>0)<($$01935$i>>>0);
       $$$0193$i = $169 ? $168 : $$01935$i;
       $$$0192$i = $169 ? $165 : $$01926$i;
       $170 = ((($165)) + 16|0);
       $171 = HEAP32[$170>>2]|0;
       $172 = ($171|0)==(0|0);
       $$sink1$i = $172&1;
       $173 = (((($165)) + 16|0) + ($$sink1$i<<2)|0);
       $174 = HEAP32[$173>>2]|0;
       $175 = ($174|0)==(0|0);
       if ($175) {
        $$0192$lcssa$i = $$$0192$i;$$0193$lcssa$i = $$$0193$i;
        break;
       } else {
        $$01926$i = $$$0192$i;$$01935$i = $$$0193$i;$165 = $174;
       }
      }
     }
     $176 = HEAP32[(177396)>>2]|0;
     $177 = ($176>>>0)>($$0192$lcssa$i>>>0);
     if ($177) {
      _abort();
      // unreachable;
     }
     $178 = (($$0192$lcssa$i) + ($25)|0);
     $179 = ($178>>>0)>($$0192$lcssa$i>>>0);
     if (!($179)) {
      _abort();
      // unreachable;
     }
     $180 = ((($$0192$lcssa$i)) + 24|0);
     $181 = HEAP32[$180>>2]|0;
     $182 = ((($$0192$lcssa$i)) + 12|0);
     $183 = HEAP32[$182>>2]|0;
     $184 = ($183|0)==($$0192$lcssa$i|0);
     do {
      if ($184) {
       $194 = ((($$0192$lcssa$i)) + 20|0);
       $195 = HEAP32[$194>>2]|0;
       $196 = ($195|0)==(0|0);
       if ($196) {
        $197 = ((($$0192$lcssa$i)) + 16|0);
        $198 = HEAP32[$197>>2]|0;
        $199 = ($198|0)==(0|0);
        if ($199) {
         $$3$i = 0;
         break;
        } else {
         $$1196$i = $198;$$1198$i = $197;
        }
       } else {
        $$1196$i = $195;$$1198$i = $194;
       }
       while(1) {
        $200 = ((($$1196$i)) + 20|0);
        $201 = HEAP32[$200>>2]|0;
        $202 = ($201|0)==(0|0);
        if (!($202)) {
         $$1196$i = $201;$$1198$i = $200;
         continue;
        }
        $203 = ((($$1196$i)) + 16|0);
        $204 = HEAP32[$203>>2]|0;
        $205 = ($204|0)==(0|0);
        if ($205) {
         break;
        } else {
         $$1196$i = $204;$$1198$i = $203;
        }
       }
       $206 = ($176>>>0)>($$1198$i>>>0);
       if ($206) {
        _abort();
        // unreachable;
       } else {
        HEAP32[$$1198$i>>2] = 0;
        $$3$i = $$1196$i;
        break;
       }
      } else {
       $185 = ((($$0192$lcssa$i)) + 8|0);
       $186 = HEAP32[$185>>2]|0;
       $187 = ($176>>>0)>($186>>>0);
       if ($187) {
        _abort();
        // unreachable;
       }
       $188 = ((($186)) + 12|0);
       $189 = HEAP32[$188>>2]|0;
       $190 = ($189|0)==($$0192$lcssa$i|0);
       if (!($190)) {
        _abort();
        // unreachable;
       }
       $191 = ((($183)) + 8|0);
       $192 = HEAP32[$191>>2]|0;
       $193 = ($192|0)==($$0192$lcssa$i|0);
       if ($193) {
        HEAP32[$188>>2] = $183;
        HEAP32[$191>>2] = $186;
        $$3$i = $183;
        break;
       } else {
        _abort();
        // unreachable;
       }
      }
     } while(0);
     $207 = ($181|0)==(0|0);
     L85: do {
      if (!($207)) {
       $208 = ((($$0192$lcssa$i)) + 28|0);
       $209 = HEAP32[$208>>2]|0;
       $210 = (177684 + ($209<<2)|0);
       $211 = HEAP32[$210>>2]|0;
       $212 = ($$0192$lcssa$i|0)==($211|0);
       do {
        if ($212) {
         HEAP32[$210>>2] = $$3$i;
         $cond$i = ($$3$i|0)==(0|0);
         if ($cond$i) {
          $213 = 1 << $209;
          $214 = $213 ^ -1;
          $215 = $127 & $214;
          HEAP32[(177384)>>2] = $215;
          break L85;
         }
        } else {
         $216 = HEAP32[(177396)>>2]|0;
         $217 = ($216>>>0)>($181>>>0);
         if ($217) {
          _abort();
          // unreachable;
         } else {
          $218 = ((($181)) + 16|0);
          $219 = HEAP32[$218>>2]|0;
          $220 = ($219|0)!=($$0192$lcssa$i|0);
          $$sink2$i = $220&1;
          $221 = (((($181)) + 16|0) + ($$sink2$i<<2)|0);
          HEAP32[$221>>2] = $$3$i;
          $222 = ($$3$i|0)==(0|0);
          if ($222) {
           break L85;
          } else {
           break;
          }
         }
        }
       } while(0);
       $223 = HEAP32[(177396)>>2]|0;
       $224 = ($223>>>0)>($$3$i>>>0);
       if ($224) {
        _abort();
        // unreachable;
       }
       $225 = ((($$3$i)) + 24|0);
       HEAP32[$225>>2] = $181;
       $226 = ((($$0192$lcssa$i)) + 16|0);
       $227 = HEAP32[$226>>2]|0;
       $228 = ($227|0)==(0|0);
       do {
        if (!($228)) {
         $229 = ($223>>>0)>($227>>>0);
         if ($229) {
          _abort();
          // unreachable;
         } else {
          $230 = ((($$3$i)) + 16|0);
          HEAP32[$230>>2] = $227;
          $231 = ((($227)) + 24|0);
          HEAP32[$231>>2] = $$3$i;
          break;
         }
        }
       } while(0);
       $232 = ((($$0192$lcssa$i)) + 20|0);
       $233 = HEAP32[$232>>2]|0;
       $234 = ($233|0)==(0|0);
       if (!($234)) {
        $235 = HEAP32[(177396)>>2]|0;
        $236 = ($235>>>0)>($233>>>0);
        if ($236) {
         _abort();
         // unreachable;
        } else {
         $237 = ((($$3$i)) + 20|0);
         HEAP32[$237>>2] = $233;
         $238 = ((($233)) + 24|0);
         HEAP32[$238>>2] = $$3$i;
         break;
        }
       }
      }
     } while(0);
     $239 = ($$0193$lcssa$i>>>0)<(16);
     if ($239) {
      $240 = (($$0193$lcssa$i) + ($25))|0;
      $241 = $240 | 3;
      $242 = ((($$0192$lcssa$i)) + 4|0);
      HEAP32[$242>>2] = $241;
      $243 = (($$0192$lcssa$i) + ($240)|0);
      $244 = ((($243)) + 4|0);
      $245 = HEAP32[$244>>2]|0;
      $246 = $245 | 1;
      HEAP32[$244>>2] = $246;
     } else {
      $247 = $25 | 3;
      $248 = ((($$0192$lcssa$i)) + 4|0);
      HEAP32[$248>>2] = $247;
      $249 = $$0193$lcssa$i | 1;
      $250 = ((($178)) + 4|0);
      HEAP32[$250>>2] = $249;
      $251 = (($178) + ($$0193$lcssa$i)|0);
      HEAP32[$251>>2] = $$0193$lcssa$i;
      $252 = ($56|0)==(0);
      if (!($252)) {
       $253 = HEAP32[(177400)>>2]|0;
       $254 = $56 >>> 3;
       $255 = $254 << 1;
       $256 = (177420 + ($255<<2)|0);
       $257 = 1 << $254;
       $258 = $27 & $257;
       $259 = ($258|0)==(0);
       if ($259) {
        $260 = $27 | $257;
        HEAP32[44345] = $260;
        $$pre$i = ((($256)) + 8|0);
        $$0189$i = $256;$$pre$phi$iZ2D = $$pre$i;
       } else {
        $261 = ((($256)) + 8|0);
        $262 = HEAP32[$261>>2]|0;
        $263 = HEAP32[(177396)>>2]|0;
        $264 = ($263>>>0)>($262>>>0);
        if ($264) {
         _abort();
         // unreachable;
        } else {
         $$0189$i = $262;$$pre$phi$iZ2D = $261;
        }
       }
       HEAP32[$$pre$phi$iZ2D>>2] = $253;
       $265 = ((($$0189$i)) + 12|0);
       HEAP32[$265>>2] = $253;
       $266 = ((($253)) + 8|0);
       HEAP32[$266>>2] = $$0189$i;
       $267 = ((($253)) + 12|0);
       HEAP32[$267>>2] = $256;
      }
      HEAP32[(177388)>>2] = $$0193$lcssa$i;
      HEAP32[(177400)>>2] = $178;
     }
     $268 = ((($$0192$lcssa$i)) + 8|0);
     $$2 = $268;
    }
   } else {
    $$0198 = $25;
    label = 153;
   }
  } else {
   $269 = ($0>>>0)>(4294967231);
   if ($269) {
    $$0198 = -1;
    label = 153;
   } else {
    $270 = (($0) + 11)|0;
    $271 = $270 & -8;
    $272 = HEAP32[(177384)>>2]|0;
    $273 = ($272|0)==(0);
    if ($273) {
     $$0198 = $271;
     label = 153;
    } else {
     $274 = (0 - ($271))|0;
     $275 = $270 >>> 8;
     $276 = ($275|0)==(0);
     if ($276) {
      $$0358$i = 0;
     } else {
      $277 = ($271>>>0)>(16777215);
      if ($277) {
       $$0358$i = 31;
      } else {
       $278 = (($275) + 1048320)|0;
       $279 = $278 >>> 16;
       $280 = $279 & 8;
       $281 = $275 << $280;
       $282 = (($281) + 520192)|0;
       $283 = $282 >>> 16;
       $284 = $283 & 4;
       $285 = $284 | $280;
       $286 = $281 << $284;
       $287 = (($286) + 245760)|0;
       $288 = $287 >>> 16;
       $289 = $288 & 2;
       $290 = $285 | $289;
       $291 = (14 - ($290))|0;
       $292 = $286 << $289;
       $293 = $292 >>> 15;
       $294 = (($291) + ($293))|0;
       $295 = $294 << 1;
       $296 = (($294) + 7)|0;
       $297 = $271 >>> $296;
       $298 = $297 & 1;
       $299 = $298 | $295;
       $$0358$i = $299;
      }
     }
     $300 = (177684 + ($$0358$i<<2)|0);
     $301 = HEAP32[$300>>2]|0;
     $302 = ($301|0)==(0|0);
     L128: do {
      if ($302) {
       $$2355$i = 0;$$3$i204 = 0;$$3350$i = $274;
       label = 90;
      } else {
       $303 = ($$0358$i|0)==(31);
       $304 = $$0358$i >>> 1;
       $305 = (25 - ($304))|0;
       $306 = $303 ? 0 : $305;
       $307 = $271 << $306;
       $$0342$i = 0;$$0347$i = $274;$$0353$i = $301;$$0359$i = $307;$$0362$i = 0;
       while(1) {
        $308 = ((($$0353$i)) + 4|0);
        $309 = HEAP32[$308>>2]|0;
        $310 = $309 & -8;
        $311 = (($310) - ($271))|0;
        $312 = ($311>>>0)<($$0347$i>>>0);
        if ($312) {
         $313 = ($311|0)==(0);
         if ($313) {
          $$414$i = $$0353$i;$$435113$i = 0;$$435712$i = $$0353$i;
          label = 94;
          break L128;
         } else {
          $$1343$i = $$0353$i;$$1348$i = $311;
         }
        } else {
         $$1343$i = $$0342$i;$$1348$i = $$0347$i;
        }
        $314 = ((($$0353$i)) + 20|0);
        $315 = HEAP32[$314>>2]|0;
        $316 = $$0359$i >>> 31;
        $317 = (((($$0353$i)) + 16|0) + ($316<<2)|0);
        $318 = HEAP32[$317>>2]|0;
        $319 = ($315|0)==(0|0);
        $320 = ($315|0)==($318|0);
        $or$cond2$i = $319 | $320;
        $$1363$i = $or$cond2$i ? $$0362$i : $315;
        $321 = ($318|0)==(0|0);
        $not$7$i = $321 ^ 1;
        $322 = $not$7$i&1;
        $$0359$$i = $$0359$i << $322;
        if ($321) {
         $$2355$i = $$1363$i;$$3$i204 = $$1343$i;$$3350$i = $$1348$i;
         label = 90;
         break;
        } else {
         $$0342$i = $$1343$i;$$0347$i = $$1348$i;$$0353$i = $318;$$0359$i = $$0359$$i;$$0362$i = $$1363$i;
        }
       }
      }
     } while(0);
     if ((label|0) == 90) {
      $323 = ($$2355$i|0)==(0|0);
      $324 = ($$3$i204|0)==(0|0);
      $or$cond$i = $323 & $324;
      if ($or$cond$i) {
       $325 = 2 << $$0358$i;
       $326 = (0 - ($325))|0;
       $327 = $325 | $326;
       $328 = $272 & $327;
       $329 = ($328|0)==(0);
       if ($329) {
        $$0198 = $271;
        label = 153;
        break;
       }
       $330 = (0 - ($328))|0;
       $331 = $328 & $330;
       $332 = (($331) + -1)|0;
       $333 = $332 >>> 12;
       $334 = $333 & 16;
       $335 = $332 >>> $334;
       $336 = $335 >>> 5;
       $337 = $336 & 8;
       $338 = $337 | $334;
       $339 = $335 >>> $337;
       $340 = $339 >>> 2;
       $341 = $340 & 4;
       $342 = $338 | $341;
       $343 = $339 >>> $341;
       $344 = $343 >>> 1;
       $345 = $344 & 2;
       $346 = $342 | $345;
       $347 = $343 >>> $345;
       $348 = $347 >>> 1;
       $349 = $348 & 1;
       $350 = $346 | $349;
       $351 = $347 >>> $349;
       $352 = (($350) + ($351))|0;
       $353 = (177684 + ($352<<2)|0);
       $354 = HEAP32[$353>>2]|0;
       $$4$ph$i = 0;$$4357$ph$i = $354;
      } else {
       $$4$ph$i = $$3$i204;$$4357$ph$i = $$2355$i;
      }
      $355 = ($$4357$ph$i|0)==(0|0);
      if ($355) {
       $$4$lcssa$i = $$4$ph$i;$$4351$lcssa$i = $$3350$i;
      } else {
       $$414$i = $$4$ph$i;$$435113$i = $$3350$i;$$435712$i = $$4357$ph$i;
       label = 94;
      }
     }
     if ((label|0) == 94) {
      while(1) {
       label = 0;
       $356 = ((($$435712$i)) + 4|0);
       $357 = HEAP32[$356>>2]|0;
       $358 = $357 & -8;
       $359 = (($358) - ($271))|0;
       $360 = ($359>>>0)<($$435113$i>>>0);
       $$$4351$i = $360 ? $359 : $$435113$i;
       $$4357$$4$i = $360 ? $$435712$i : $$414$i;
       $361 = ((($$435712$i)) + 16|0);
       $362 = HEAP32[$361>>2]|0;
       $363 = ($362|0)==(0|0);
       $$sink2$i206 = $363&1;
       $364 = (((($$435712$i)) + 16|0) + ($$sink2$i206<<2)|0);
       $365 = HEAP32[$364>>2]|0;
       $366 = ($365|0)==(0|0);
       if ($366) {
        $$4$lcssa$i = $$4357$$4$i;$$4351$lcssa$i = $$$4351$i;
        break;
       } else {
        $$414$i = $$4357$$4$i;$$435113$i = $$$4351$i;$$435712$i = $365;
        label = 94;
       }
      }
     }
     $367 = ($$4$lcssa$i|0)==(0|0);
     if ($367) {
      $$0198 = $271;
      label = 153;
     } else {
      $368 = HEAP32[(177388)>>2]|0;
      $369 = (($368) - ($271))|0;
      $370 = ($$4351$lcssa$i>>>0)<($369>>>0);
      if ($370) {
       $371 = HEAP32[(177396)>>2]|0;
       $372 = ($371>>>0)>($$4$lcssa$i>>>0);
       if ($372) {
        _abort();
        // unreachable;
       }
       $373 = (($$4$lcssa$i) + ($271)|0);
       $374 = ($373>>>0)>($$4$lcssa$i>>>0);
       if (!($374)) {
        _abort();
        // unreachable;
       }
       $375 = ((($$4$lcssa$i)) + 24|0);
       $376 = HEAP32[$375>>2]|0;
       $377 = ((($$4$lcssa$i)) + 12|0);
       $378 = HEAP32[$377>>2]|0;
       $379 = ($378|0)==($$4$lcssa$i|0);
       do {
        if ($379) {
         $389 = ((($$4$lcssa$i)) + 20|0);
         $390 = HEAP32[$389>>2]|0;
         $391 = ($390|0)==(0|0);
         if ($391) {
          $392 = ((($$4$lcssa$i)) + 16|0);
          $393 = HEAP32[$392>>2]|0;
          $394 = ($393|0)==(0|0);
          if ($394) {
           $$3372$i = 0;
           break;
          } else {
           $$1370$i = $393;$$1374$i = $392;
          }
         } else {
          $$1370$i = $390;$$1374$i = $389;
         }
         while(1) {
          $395 = ((($$1370$i)) + 20|0);
          $396 = HEAP32[$395>>2]|0;
          $397 = ($396|0)==(0|0);
          if (!($397)) {
           $$1370$i = $396;$$1374$i = $395;
           continue;
          }
          $398 = ((($$1370$i)) + 16|0);
          $399 = HEAP32[$398>>2]|0;
          $400 = ($399|0)==(0|0);
          if ($400) {
           break;
          } else {
           $$1370$i = $399;$$1374$i = $398;
          }
         }
         $401 = ($371>>>0)>($$1374$i>>>0);
         if ($401) {
          _abort();
          // unreachable;
         } else {
          HEAP32[$$1374$i>>2] = 0;
          $$3372$i = $$1370$i;
          break;
         }
        } else {
         $380 = ((($$4$lcssa$i)) + 8|0);
         $381 = HEAP32[$380>>2]|0;
         $382 = ($371>>>0)>($381>>>0);
         if ($382) {
          _abort();
          // unreachable;
         }
         $383 = ((($381)) + 12|0);
         $384 = HEAP32[$383>>2]|0;
         $385 = ($384|0)==($$4$lcssa$i|0);
         if (!($385)) {
          _abort();
          // unreachable;
         }
         $386 = ((($378)) + 8|0);
         $387 = HEAP32[$386>>2]|0;
         $388 = ($387|0)==($$4$lcssa$i|0);
         if ($388) {
          HEAP32[$383>>2] = $378;
          HEAP32[$386>>2] = $381;
          $$3372$i = $378;
          break;
         } else {
          _abort();
          // unreachable;
         }
        }
       } while(0);
       $402 = ($376|0)==(0|0);
       L175: do {
        if ($402) {
         $494 = $272;
        } else {
         $403 = ((($$4$lcssa$i)) + 28|0);
         $404 = HEAP32[$403>>2]|0;
         $405 = (177684 + ($404<<2)|0);
         $406 = HEAP32[$405>>2]|0;
         $407 = ($$4$lcssa$i|0)==($406|0);
         do {
          if ($407) {
           HEAP32[$405>>2] = $$3372$i;
           $cond$i210 = ($$3372$i|0)==(0|0);
           if ($cond$i210) {
            $408 = 1 << $404;
            $409 = $408 ^ -1;
            $410 = $272 & $409;
            HEAP32[(177384)>>2] = $410;
            $494 = $410;
            break L175;
           }
          } else {
           $411 = HEAP32[(177396)>>2]|0;
           $412 = ($411>>>0)>($376>>>0);
           if ($412) {
            _abort();
            // unreachable;
           } else {
            $413 = ((($376)) + 16|0);
            $414 = HEAP32[$413>>2]|0;
            $415 = ($414|0)!=($$4$lcssa$i|0);
            $$sink3$i = $415&1;
            $416 = (((($376)) + 16|0) + ($$sink3$i<<2)|0);
            HEAP32[$416>>2] = $$3372$i;
            $417 = ($$3372$i|0)==(0|0);
            if ($417) {
             $494 = $272;
             break L175;
            } else {
             break;
            }
           }
          }
         } while(0);
         $418 = HEAP32[(177396)>>2]|0;
         $419 = ($418>>>0)>($$3372$i>>>0);
         if ($419) {
          _abort();
          // unreachable;
         }
         $420 = ((($$3372$i)) + 24|0);
         HEAP32[$420>>2] = $376;
         $421 = ((($$4$lcssa$i)) + 16|0);
         $422 = HEAP32[$421>>2]|0;
         $423 = ($422|0)==(0|0);
         do {
          if (!($423)) {
           $424 = ($418>>>0)>($422>>>0);
           if ($424) {
            _abort();
            // unreachable;
           } else {
            $425 = ((($$3372$i)) + 16|0);
            HEAP32[$425>>2] = $422;
            $426 = ((($422)) + 24|0);
            HEAP32[$426>>2] = $$3372$i;
            break;
           }
          }
         } while(0);
         $427 = ((($$4$lcssa$i)) + 20|0);
         $428 = HEAP32[$427>>2]|0;
         $429 = ($428|0)==(0|0);
         if ($429) {
          $494 = $272;
         } else {
          $430 = HEAP32[(177396)>>2]|0;
          $431 = ($430>>>0)>($428>>>0);
          if ($431) {
           _abort();
           // unreachable;
          } else {
           $432 = ((($$3372$i)) + 20|0);
           HEAP32[$432>>2] = $428;
           $433 = ((($428)) + 24|0);
           HEAP32[$433>>2] = $$3372$i;
           $494 = $272;
           break;
          }
         }
        }
       } while(0);
       $434 = ($$4351$lcssa$i>>>0)<(16);
       do {
        if ($434) {
         $435 = (($$4351$lcssa$i) + ($271))|0;
         $436 = $435 | 3;
         $437 = ((($$4$lcssa$i)) + 4|0);
         HEAP32[$437>>2] = $436;
         $438 = (($$4$lcssa$i) + ($435)|0);
         $439 = ((($438)) + 4|0);
         $440 = HEAP32[$439>>2]|0;
         $441 = $440 | 1;
         HEAP32[$439>>2] = $441;
        } else {
         $442 = $271 | 3;
         $443 = ((($$4$lcssa$i)) + 4|0);
         HEAP32[$443>>2] = $442;
         $444 = $$4351$lcssa$i | 1;
         $445 = ((($373)) + 4|0);
         HEAP32[$445>>2] = $444;
         $446 = (($373) + ($$4351$lcssa$i)|0);
         HEAP32[$446>>2] = $$4351$lcssa$i;
         $447 = $$4351$lcssa$i >>> 3;
         $448 = ($$4351$lcssa$i>>>0)<(256);
         if ($448) {
          $449 = $447 << 1;
          $450 = (177420 + ($449<<2)|0);
          $451 = HEAP32[44345]|0;
          $452 = 1 << $447;
          $453 = $451 & $452;
          $454 = ($453|0)==(0);
          do {
           if ($454) {
            $455 = $451 | $452;
            HEAP32[44345] = $455;
            $$pre$i211 = ((($450)) + 8|0);
            $$0368$i = $450;$$pre$phi$i212Z2D = $$pre$i211;
           } else {
            $456 = ((($450)) + 8|0);
            $457 = HEAP32[$456>>2]|0;
            $458 = HEAP32[(177396)>>2]|0;
            $459 = ($458>>>0)>($457>>>0);
            if (!($459)) {
             $$0368$i = $457;$$pre$phi$i212Z2D = $456;
             break;
            }
            _abort();
            // unreachable;
           }
          } while(0);
          HEAP32[$$pre$phi$i212Z2D>>2] = $373;
          $460 = ((($$0368$i)) + 12|0);
          HEAP32[$460>>2] = $373;
          $461 = ((($373)) + 8|0);
          HEAP32[$461>>2] = $$0368$i;
          $462 = ((($373)) + 12|0);
          HEAP32[$462>>2] = $450;
          break;
         }
         $463 = $$4351$lcssa$i >>> 8;
         $464 = ($463|0)==(0);
         if ($464) {
          $$0361$i = 0;
         } else {
          $465 = ($$4351$lcssa$i>>>0)>(16777215);
          if ($465) {
           $$0361$i = 31;
          } else {
           $466 = (($463) + 1048320)|0;
           $467 = $466 >>> 16;
           $468 = $467 & 8;
           $469 = $463 << $468;
           $470 = (($469) + 520192)|0;
           $471 = $470 >>> 16;
           $472 = $471 & 4;
           $473 = $472 | $468;
           $474 = $469 << $472;
           $475 = (($474) + 245760)|0;
           $476 = $475 >>> 16;
           $477 = $476 & 2;
           $478 = $473 | $477;
           $479 = (14 - ($478))|0;
           $480 = $474 << $477;
           $481 = $480 >>> 15;
           $482 = (($479) + ($481))|0;
           $483 = $482 << 1;
           $484 = (($482) + 7)|0;
           $485 = $$4351$lcssa$i >>> $484;
           $486 = $485 & 1;
           $487 = $486 | $483;
           $$0361$i = $487;
          }
         }
         $488 = (177684 + ($$0361$i<<2)|0);
         $489 = ((($373)) + 28|0);
         HEAP32[$489>>2] = $$0361$i;
         $490 = ((($373)) + 16|0);
         $491 = ((($490)) + 4|0);
         HEAP32[$491>>2] = 0;
         HEAP32[$490>>2] = 0;
         $492 = 1 << $$0361$i;
         $493 = $494 & $492;
         $495 = ($493|0)==(0);
         if ($495) {
          $496 = $494 | $492;
          HEAP32[(177384)>>2] = $496;
          HEAP32[$488>>2] = $373;
          $497 = ((($373)) + 24|0);
          HEAP32[$497>>2] = $488;
          $498 = ((($373)) + 12|0);
          HEAP32[$498>>2] = $373;
          $499 = ((($373)) + 8|0);
          HEAP32[$499>>2] = $373;
          break;
         }
         $500 = HEAP32[$488>>2]|0;
         $501 = ($$0361$i|0)==(31);
         $502 = $$0361$i >>> 1;
         $503 = (25 - ($502))|0;
         $504 = $501 ? 0 : $503;
         $505 = $$4351$lcssa$i << $504;
         $$0344$i = $505;$$0345$i = $500;
         while(1) {
          $506 = ((($$0345$i)) + 4|0);
          $507 = HEAP32[$506>>2]|0;
          $508 = $507 & -8;
          $509 = ($508|0)==($$4351$lcssa$i|0);
          if ($509) {
           label = 148;
           break;
          }
          $510 = $$0344$i >>> 31;
          $511 = (((($$0345$i)) + 16|0) + ($510<<2)|0);
          $512 = $$0344$i << 1;
          $513 = HEAP32[$511>>2]|0;
          $514 = ($513|0)==(0|0);
          if ($514) {
           label = 145;
           break;
          } else {
           $$0344$i = $512;$$0345$i = $513;
          }
         }
         if ((label|0) == 145) {
          $515 = HEAP32[(177396)>>2]|0;
          $516 = ($515>>>0)>($511>>>0);
          if ($516) {
           _abort();
           // unreachable;
          } else {
           HEAP32[$511>>2] = $373;
           $517 = ((($373)) + 24|0);
           HEAP32[$517>>2] = $$0345$i;
           $518 = ((($373)) + 12|0);
           HEAP32[$518>>2] = $373;
           $519 = ((($373)) + 8|0);
           HEAP32[$519>>2] = $373;
           break;
          }
         }
         else if ((label|0) == 148) {
          $520 = ((($$0345$i)) + 8|0);
          $521 = HEAP32[$520>>2]|0;
          $522 = HEAP32[(177396)>>2]|0;
          $523 = ($522>>>0)<=($$0345$i>>>0);
          $524 = ($522>>>0)<=($521>>>0);
          $525 = $524 & $523;
          if ($525) {
           $526 = ((($521)) + 12|0);
           HEAP32[$526>>2] = $373;
           HEAP32[$520>>2] = $373;
           $527 = ((($373)) + 8|0);
           HEAP32[$527>>2] = $521;
           $528 = ((($373)) + 12|0);
           HEAP32[$528>>2] = $$0345$i;
           $529 = ((($373)) + 24|0);
           HEAP32[$529>>2] = 0;
           break;
          } else {
           _abort();
           // unreachable;
          }
         }
        }
       } while(0);
       $530 = ((($$4$lcssa$i)) + 8|0);
       $$2 = $530;
      } else {
       $$0198 = $271;
       label = 153;
      }
     }
    }
   }
  }
 } while(0);
 L230: do {
  if ((label|0) == 153) {
   $531 = HEAP32[(177388)>>2]|0;
   $532 = ($531>>>0)<($$0198>>>0);
   if (!($532)) {
    $533 = (($531) - ($$0198))|0;
    $534 = HEAP32[(177400)>>2]|0;
    $535 = ($533>>>0)>(15);
    if ($535) {
     $536 = (($534) + ($$0198)|0);
     HEAP32[(177400)>>2] = $536;
     HEAP32[(177388)>>2] = $533;
     $537 = $533 | 1;
     $538 = ((($536)) + 4|0);
     HEAP32[$538>>2] = $537;
     $539 = (($534) + ($531)|0);
     HEAP32[$539>>2] = $533;
     $540 = $$0198 | 3;
     $541 = ((($534)) + 4|0);
     HEAP32[$541>>2] = $540;
    } else {
     HEAP32[(177388)>>2] = 0;
     HEAP32[(177400)>>2] = 0;
     $542 = $531 | 3;
     $543 = ((($534)) + 4|0);
     HEAP32[$543>>2] = $542;
     $544 = (($534) + ($531)|0);
     $545 = ((($544)) + 4|0);
     $546 = HEAP32[$545>>2]|0;
     $547 = $546 | 1;
     HEAP32[$545>>2] = $547;
    }
    $548 = ((($534)) + 8|0);
    $$2 = $548;
    break;
   }
   $549 = HEAP32[(177392)>>2]|0;
   $550 = ($549>>>0)>($$0198>>>0);
   if ($550) {
    $551 = (($549) - ($$0198))|0;
    HEAP32[(177392)>>2] = $551;
    $552 = HEAP32[(177404)>>2]|0;
    $553 = (($552) + ($$0198)|0);
    HEAP32[(177404)>>2] = $553;
    $554 = $551 | 1;
    $555 = ((($553)) + 4|0);
    HEAP32[$555>>2] = $554;
    $556 = $$0198 | 3;
    $557 = ((($552)) + 4|0);
    HEAP32[$557>>2] = $556;
    $558 = ((($552)) + 8|0);
    $$2 = $558;
    break;
   }
   $559 = HEAP32[44332]|0;
   $560 = ($559|0)==(0);
   if ($560) {
    (___pthread_mutex_lock(177352)|0);
    $561 = HEAP32[44332]|0;
    $562 = ($561|0)==(0);
    if ($562) {
     HEAP32[(177336)>>2] = 4096;
     HEAP32[(177332)>>2] = 4096;
     HEAP32[(177340)>>2] = -1;
     HEAP32[(177344)>>2] = -1;
     HEAP32[(177348)>>2] = 2;
     HEAP32[(177824)>>2] = 2;
     $563 = (_pthread_mutexattr_init($1)|0);
     $564 = ($563|0)==(0);
     if ($564) {
      $565 = (_pthread_mutex_init((177828),$1)|0);
      $566 = ($565|0)==(0);
      if ($566) {
      }
     }
     $567 = $2;
     $568 = $567 & -16;
     $569 = $568 ^ 1431655768;
     Atomics_store(HEAP32,44332,$569)|0;
    }
    (___pthread_mutex_unlock(177352)|0);
   }
   $570 = (($$0198) + 48)|0;
   $571 = HEAP32[(177336)>>2]|0;
   $572 = (($$0198) + 47)|0;
   $573 = (($571) + ($572))|0;
   $574 = (0 - ($571))|0;
   $575 = $573 & $574;
   $576 = ($575>>>0)>($$0198>>>0);
   if ($576) {
    $577 = HEAP32[(177820)>>2]|0;
    $578 = ($577|0)==(0);
    if (!($578)) {
     $579 = HEAP32[(177812)>>2]|0;
     $580 = (($579) + ($575))|0;
     $581 = ($580>>>0)<=($579>>>0);
     $582 = ($580>>>0)>($577>>>0);
     $or$cond1$i = $581 | $582;
     if ($or$cond1$i) {
      $$2 = 0;
      break;
     }
    }
    $583 = HEAP32[(177824)>>2]|0;
    $584 = $583 & 4;
    $585 = ($584|0)==(0);
    if ($585) {
     $586 = HEAP32[(177404)>>2]|0;
     $587 = ($586|0)==(0|0);
     L258: do {
      if ($587) {
       label = 176;
      } else {
       $$0$i$i = (177856);
       while(1) {
        $588 = HEAP32[$$0$i$i>>2]|0;
        $589 = ($588>>>0)>($586>>>0);
        if (!($589)) {
         $590 = ((($$0$i$i)) + 4|0);
         $591 = HEAP32[$590>>2]|0;
         $592 = (($588) + ($591)|0);
         $593 = ($592>>>0)>($586>>>0);
         if ($593) {
          break;
         }
        }
        $594 = ((($$0$i$i)) + 8|0);
        $595 = HEAP32[$594>>2]|0;
        $596 = ($595|0)==(0|0);
        if ($596) {
         label = 176;
         break L258;
        } else {
         $$0$i$i = $595;
        }
       }
       (___pthread_mutex_lock(177352)|0);
       $619 = HEAP32[(177392)>>2]|0;
       $620 = HEAP32[(177336)>>2]|0;
       $621 = (($572) - ($619))|0;
       $622 = (($621) + ($620))|0;
       $623 = (0 - ($620))|0;
       $624 = $622 & $623;
       $625 = ($624>>>0)<(2147483647);
       if ($625) {
        $626 = (_sbrk(($624|0))|0);
        $627 = HEAP32[$$0$i$i>>2]|0;
        $628 = HEAP32[$590>>2]|0;
        $629 = (($627) + ($628)|0);
        $630 = ($626|0)==($629|0);
        if ($630) {
         $631 = ($626|0)==((-1)|0);
         if ($631) {
          $$2234243136$i = $624;
          label = 190;
         } else {
          $$3229$i = $626;$$3235$i = $624;
         }
        } else {
         $$2247$ph$i = $626;$$2253$ph$i = $624;
         label = 184;
        }
       } else {
        $$2234243136$i = 0;
        label = 190;
       }
      }
     } while(0);
     do {
      if ((label|0) == 176) {
       (___pthread_mutex_lock(177352)|0);
       $597 = (_sbrk(0)|0);
       $598 = ($597|0)==((-1)|0);
       if ($598) {
        $$2234243136$i = 0;
        label = 190;
       } else {
        $599 = $597;
        $600 = HEAP32[(177332)>>2]|0;
        $601 = (($600) + -1)|0;
        $602 = $601 & $599;
        $603 = ($602|0)==(0);
        $604 = (($601) + ($599))|0;
        $605 = (0 - ($600))|0;
        $606 = $604 & $605;
        $607 = (($606) - ($599))|0;
        $608 = $603 ? 0 : $607;
        $$$i = (($608) + ($575))|0;
        $609 = HEAP32[(177812)>>2]|0;
        $610 = (($$$i) + ($609))|0;
        $611 = ($$$i>>>0)>($$0198>>>0);
        $612 = ($$$i>>>0)<(2147483647);
        $or$cond$i213 = $611 & $612;
        if ($or$cond$i213) {
         $613 = HEAP32[(177820)>>2]|0;
         $614 = ($613|0)==(0);
         if (!($614)) {
          $615 = ($610>>>0)<=($609>>>0);
          $616 = ($610>>>0)>($613>>>0);
          $or$cond2$i214 = $615 | $616;
          if ($or$cond2$i214) {
           $$2234243136$i = 0;
           label = 190;
           break;
          }
         }
         $617 = (_sbrk(($$$i|0))|0);
         $618 = ($617|0)==($597|0);
         if ($618) {
          $$3229$i = $597;$$3235$i = $$$i;
         } else {
          $$2247$ph$i = $617;$$2253$ph$i = $$$i;
          label = 184;
         }
        } else {
         $$2234243136$i = 0;
         label = 190;
        }
       }
      }
     } while(0);
     do {
      if ((label|0) == 184) {
       $632 = (0 - ($$2253$ph$i))|0;
       $633 = ($$2247$ph$i|0)!=((-1)|0);
       $634 = ($$2253$ph$i>>>0)<(2147483647);
       $or$cond7$i = $634 & $633;
       $635 = ($570>>>0)>($$2253$ph$i>>>0);
       $or$cond10$i = $635 & $or$cond7$i;
       if (!($or$cond10$i)) {
        $645 = ($$2247$ph$i|0)==((-1)|0);
        if ($645) {
         $$2234243136$i = 0;
         label = 190;
         break;
        } else {
         $$3229$i = $$2247$ph$i;$$3235$i = $$2253$ph$i;
         break;
        }
       }
       $636 = HEAP32[(177336)>>2]|0;
       $637 = (($572) - ($$2253$ph$i))|0;
       $638 = (($637) + ($636))|0;
       $639 = (0 - ($636))|0;
       $640 = $638 & $639;
       $641 = ($640>>>0)<(2147483647);
       if ($641) {
        $642 = (_sbrk(($640|0))|0);
        $643 = ($642|0)==((-1)|0);
        if ($643) {
         (_sbrk(($632|0))|0);
         $$2234243136$i = 0;
         label = 190;
         break;
        } else {
         $644 = (($640) + ($$2253$ph$i))|0;
         $$3229$i = $$2247$ph$i;$$3235$i = $644;
         break;
        }
       } else {
        $$3229$i = $$2247$ph$i;$$3235$i = $$2253$ph$i;
       }
      }
     } while(0);
     if ((label|0) == 190) {
      $646 = HEAP32[(177824)>>2]|0;
      $647 = $646 | 4;
      HEAP32[(177824)>>2] = $647;
      $$3229$i = (-1);$$3235$i = $$2234243136$i;
     }
     (___pthread_mutex_unlock(177352)|0);
     $$4230$i = $$3229$i;$$4236$i = $$3235$i;
    } else {
     $$4230$i = (-1);$$4236$i = 0;
    }
    $648 = ($$4230$i|0)==((-1)|0);
    $649 = ($575>>>0)<(2147483647);
    $or$cond9$i = $649 & $648;
    if ($or$cond9$i) {
     (___pthread_mutex_lock(177352)|0);
     $650 = (_sbrk(($575|0))|0);
     $651 = (_sbrk(0)|0);
     (___pthread_mutex_unlock(177352)|0);
     $652 = ($650|0)!=((-1)|0);
     $653 = ($651|0)!=((-1)|0);
     $or$cond5$i = $652 & $653;
     $654 = ($650>>>0)<($651>>>0);
     $or$cond11$i = $654 & $or$cond5$i;
     $655 = $651;
     $656 = $650;
     $657 = (($655) - ($656))|0;
     $658 = (($$0198) + 40)|0;
     $659 = ($657>>>0)>($658>>>0);
     $$$4236$i = $659 ? $657 : $$4236$i;
     $$$4230$i = $659 ? $650 : (-1);
     if ($or$cond11$i) {
      $$7$i = $$$4230$i;$$7239$i = $$$4236$i;
      label = 194;
     }
    } else {
     $$7$i = $$4230$i;$$7239$i = $$4236$i;
     label = 194;
    }
    if ((label|0) == 194) {
     $660 = ($$7$i|0)==((-1)|0);
     if (!($660)) {
      $661 = HEAP32[(177812)>>2]|0;
      $662 = (($661) + ($$7239$i))|0;
      HEAP32[(177812)>>2] = $662;
      $663 = HEAP32[(177816)>>2]|0;
      $664 = ($662>>>0)>($663>>>0);
      if ($664) {
       HEAP32[(177816)>>2] = $662;
      }
      $665 = HEAP32[(177404)>>2]|0;
      $666 = ($665|0)==(0|0);
      do {
       if ($666) {
        $667 = HEAP32[(177396)>>2]|0;
        $668 = ($667|0)==(0|0);
        $669 = ($$7$i>>>0)<($667>>>0);
        $or$cond12$i = $668 | $669;
        if ($or$cond12$i) {
         HEAP32[(177396)>>2] = $$7$i;
        }
        HEAP32[(177856)>>2] = $$7$i;
        HEAP32[(177860)>>2] = $$7239$i;
        HEAP32[(177868)>>2] = 0;
        $670 = HEAP32[44332]|0;
        HEAP32[(177416)>>2] = $670;
        HEAP32[(177412)>>2] = -1;
        HEAP32[(177432)>>2] = (177420);
        HEAP32[(177428)>>2] = (177420);
        HEAP32[(177440)>>2] = (177428);
        HEAP32[(177436)>>2] = (177428);
        HEAP32[(177448)>>2] = (177436);
        HEAP32[(177444)>>2] = (177436);
        HEAP32[(177456)>>2] = (177444);
        HEAP32[(177452)>>2] = (177444);
        HEAP32[(177464)>>2] = (177452);
        HEAP32[(177460)>>2] = (177452);
        HEAP32[(177472)>>2] = (177460);
        HEAP32[(177468)>>2] = (177460);
        HEAP32[(177480)>>2] = (177468);
        HEAP32[(177476)>>2] = (177468);
        HEAP32[(177488)>>2] = (177476);
        HEAP32[(177484)>>2] = (177476);
        HEAP32[(177496)>>2] = (177484);
        HEAP32[(177492)>>2] = (177484);
        HEAP32[(177504)>>2] = (177492);
        HEAP32[(177500)>>2] = (177492);
        HEAP32[(177512)>>2] = (177500);
        HEAP32[(177508)>>2] = (177500);
        HEAP32[(177520)>>2] = (177508);
        HEAP32[(177516)>>2] = (177508);
        HEAP32[(177528)>>2] = (177516);
        HEAP32[(177524)>>2] = (177516);
        HEAP32[(177536)>>2] = (177524);
        HEAP32[(177532)>>2] = (177524);
        HEAP32[(177544)>>2] = (177532);
        HEAP32[(177540)>>2] = (177532);
        HEAP32[(177552)>>2] = (177540);
        HEAP32[(177548)>>2] = (177540);
        HEAP32[(177560)>>2] = (177548);
        HEAP32[(177556)>>2] = (177548);
        HEAP32[(177568)>>2] = (177556);
        HEAP32[(177564)>>2] = (177556);
        HEAP32[(177576)>>2] = (177564);
        HEAP32[(177572)>>2] = (177564);
        HEAP32[(177584)>>2] = (177572);
        HEAP32[(177580)>>2] = (177572);
        HEAP32[(177592)>>2] = (177580);
        HEAP32[(177588)>>2] = (177580);
        HEAP32[(177600)>>2] = (177588);
        HEAP32[(177596)>>2] = (177588);
        HEAP32[(177608)>>2] = (177596);
        HEAP32[(177604)>>2] = (177596);
        HEAP32[(177616)>>2] = (177604);
        HEAP32[(177612)>>2] = (177604);
        HEAP32[(177624)>>2] = (177612);
        HEAP32[(177620)>>2] = (177612);
        HEAP32[(177632)>>2] = (177620);
        HEAP32[(177628)>>2] = (177620);
        HEAP32[(177640)>>2] = (177628);
        HEAP32[(177636)>>2] = (177628);
        HEAP32[(177648)>>2] = (177636);
        HEAP32[(177644)>>2] = (177636);
        HEAP32[(177656)>>2] = (177644);
        HEAP32[(177652)>>2] = (177644);
        HEAP32[(177664)>>2] = (177652);
        HEAP32[(177660)>>2] = (177652);
        HEAP32[(177672)>>2] = (177660);
        HEAP32[(177668)>>2] = (177660);
        HEAP32[(177680)>>2] = (177668);
        HEAP32[(177676)>>2] = (177668);
        $671 = (($$7239$i) + -40)|0;
        $672 = ((($$7$i)) + 8|0);
        $673 = $672;
        $674 = $673 & 7;
        $675 = ($674|0)==(0);
        $676 = (0 - ($673))|0;
        $677 = $676 & 7;
        $678 = $675 ? 0 : $677;
        $679 = (($$7$i) + ($678)|0);
        $680 = (($671) - ($678))|0;
        HEAP32[(177404)>>2] = $679;
        HEAP32[(177392)>>2] = $680;
        $681 = $680 | 1;
        $682 = ((($679)) + 4|0);
        HEAP32[$682>>2] = $681;
        $683 = (($$7$i) + ($671)|0);
        $684 = ((($683)) + 4|0);
        HEAP32[$684>>2] = 40;
        $685 = HEAP32[(177344)>>2]|0;
        HEAP32[(177408)>>2] = $685;
       } else {
        $$024359$i = (177856);
        while(1) {
         $686 = HEAP32[$$024359$i>>2]|0;
         $687 = ((($$024359$i)) + 4|0);
         $688 = HEAP32[$687>>2]|0;
         $689 = (($686) + ($688)|0);
         $690 = ($$7$i|0)==($689|0);
         if ($690) {
          label = 203;
          break;
         }
         $691 = ((($$024359$i)) + 8|0);
         $692 = HEAP32[$691>>2]|0;
         $693 = ($692|0)==(0|0);
         if ($693) {
          break;
         } else {
          $$024359$i = $692;
         }
        }
        if ((label|0) == 203) {
         $694 = ((($$024359$i)) + 12|0);
         $695 = HEAP32[$694>>2]|0;
         $696 = $695 & 8;
         $697 = ($696|0)==(0);
         if ($697) {
          $698 = ($686>>>0)<=($665>>>0);
          $699 = ($$7$i>>>0)>($665>>>0);
          $or$cond42$i = $699 & $698;
          if ($or$cond42$i) {
           $700 = (($688) + ($$7239$i))|0;
           HEAP32[$687>>2] = $700;
           $701 = HEAP32[(177392)>>2]|0;
           $702 = (($701) + ($$7239$i))|0;
           $703 = ((($665)) + 8|0);
           $704 = $703;
           $705 = $704 & 7;
           $706 = ($705|0)==(0);
           $707 = (0 - ($704))|0;
           $708 = $707 & 7;
           $709 = $706 ? 0 : $708;
           $710 = (($665) + ($709)|0);
           $711 = (($702) - ($709))|0;
           HEAP32[(177404)>>2] = $710;
           HEAP32[(177392)>>2] = $711;
           $712 = $711 | 1;
           $713 = ((($710)) + 4|0);
           HEAP32[$713>>2] = $712;
           $714 = (($665) + ($702)|0);
           $715 = ((($714)) + 4|0);
           HEAP32[$715>>2] = 40;
           $716 = HEAP32[(177344)>>2]|0;
           HEAP32[(177408)>>2] = $716;
           break;
          }
         }
        }
        $717 = HEAP32[(177396)>>2]|0;
        $718 = ($$7$i>>>0)<($717>>>0);
        if ($718) {
         HEAP32[(177396)>>2] = $$7$i;
         $782 = $$7$i;
        } else {
         $782 = $717;
        }
        $719 = (($$7$i) + ($$7239$i)|0);
        $$124458$i = (177856);
        while(1) {
         $720 = HEAP32[$$124458$i>>2]|0;
         $721 = ($720|0)==($719|0);
         if ($721) {
          label = 211;
          break;
         }
         $722 = ((($$124458$i)) + 8|0);
         $723 = HEAP32[$722>>2]|0;
         $724 = ($723|0)==(0|0);
         if ($724) {
          $$0$i$i$i = (177856);
          break;
         } else {
          $$124458$i = $723;
         }
        }
        if ((label|0) == 211) {
         $725 = ((($$124458$i)) + 12|0);
         $726 = HEAP32[$725>>2]|0;
         $727 = $726 & 8;
         $728 = ($727|0)==(0);
         if ($728) {
          HEAP32[$$124458$i>>2] = $$7$i;
          $729 = ((($$124458$i)) + 4|0);
          $730 = HEAP32[$729>>2]|0;
          $731 = (($730) + ($$7239$i))|0;
          HEAP32[$729>>2] = $731;
          $732 = ((($$7$i)) + 8|0);
          $733 = $732;
          $734 = $733 & 7;
          $735 = ($734|0)==(0);
          $736 = (0 - ($733))|0;
          $737 = $736 & 7;
          $738 = $735 ? 0 : $737;
          $739 = (($$7$i) + ($738)|0);
          $740 = ((($719)) + 8|0);
          $741 = $740;
          $742 = $741 & 7;
          $743 = ($742|0)==(0);
          $744 = (0 - ($741))|0;
          $745 = $744 & 7;
          $746 = $743 ? 0 : $745;
          $747 = (($719) + ($746)|0);
          $748 = $747;
          $749 = $739;
          $750 = (($748) - ($749))|0;
          $751 = (($739) + ($$0198)|0);
          $752 = (($750) - ($$0198))|0;
          $753 = $$0198 | 3;
          $754 = ((($739)) + 4|0);
          HEAP32[$754>>2] = $753;
          $755 = ($665|0)==($747|0);
          do {
           if ($755) {
            $756 = HEAP32[(177392)>>2]|0;
            $757 = (($756) + ($752))|0;
            HEAP32[(177392)>>2] = $757;
            HEAP32[(177404)>>2] = $751;
            $758 = $757 | 1;
            $759 = ((($751)) + 4|0);
            HEAP32[$759>>2] = $758;
           } else {
            $760 = HEAP32[(177400)>>2]|0;
            $761 = ($760|0)==($747|0);
            if ($761) {
             $762 = HEAP32[(177388)>>2]|0;
             $763 = (($762) + ($752))|0;
             HEAP32[(177388)>>2] = $763;
             HEAP32[(177400)>>2] = $751;
             $764 = $763 | 1;
             $765 = ((($751)) + 4|0);
             HEAP32[$765>>2] = $764;
             $766 = (($751) + ($763)|0);
             HEAP32[$766>>2] = $763;
             break;
            }
            $767 = ((($747)) + 4|0);
            $768 = HEAP32[$767>>2]|0;
            $769 = $768 & 3;
            $770 = ($769|0)==(1);
            if ($770) {
             $771 = $768 & -8;
             $772 = $768 >>> 3;
             $773 = ($768>>>0)<(256);
             L326: do {
              if ($773) {
               $774 = ((($747)) + 8|0);
               $775 = HEAP32[$774>>2]|0;
               $776 = ((($747)) + 12|0);
               $777 = HEAP32[$776>>2]|0;
               $778 = $772 << 1;
               $779 = (177420 + ($778<<2)|0);
               $780 = ($775|0)==($779|0);
               do {
                if (!($780)) {
                 $781 = ($782>>>0)>($775>>>0);
                 if ($781) {
                  _abort();
                  // unreachable;
                 }
                 $783 = ((($775)) + 12|0);
                 $784 = HEAP32[$783>>2]|0;
                 $785 = ($784|0)==($747|0);
                 if ($785) {
                  break;
                 }
                 _abort();
                 // unreachable;
                }
               } while(0);
               $786 = ($777|0)==($775|0);
               if ($786) {
                $787 = 1 << $772;
                $788 = $787 ^ -1;
                $789 = HEAP32[44345]|0;
                $790 = $789 & $788;
                HEAP32[44345] = $790;
                break;
               }
               $791 = ($777|0)==($779|0);
               do {
                if ($791) {
                 $$pre10$i$i = ((($777)) + 8|0);
                 $$pre$phi11$i$iZ2D = $$pre10$i$i;
                } else {
                 $792 = ($782>>>0)>($777>>>0);
                 if ($792) {
                  _abort();
                  // unreachable;
                 }
                 $793 = ((($777)) + 8|0);
                 $794 = HEAP32[$793>>2]|0;
                 $795 = ($794|0)==($747|0);
                 if ($795) {
                  $$pre$phi11$i$iZ2D = $793;
                  break;
                 }
                 _abort();
                 // unreachable;
                }
               } while(0);
               $796 = ((($775)) + 12|0);
               HEAP32[$796>>2] = $777;
               HEAP32[$$pre$phi11$i$iZ2D>>2] = $775;
              } else {
               $797 = ((($747)) + 24|0);
               $798 = HEAP32[$797>>2]|0;
               $799 = ((($747)) + 12|0);
               $800 = HEAP32[$799>>2]|0;
               $801 = ($800|0)==($747|0);
               do {
                if ($801) {
                 $811 = ((($747)) + 16|0);
                 $812 = ((($811)) + 4|0);
                 $813 = HEAP32[$812>>2]|0;
                 $814 = ($813|0)==(0|0);
                 if ($814) {
                  $815 = HEAP32[$811>>2]|0;
                  $816 = ($815|0)==(0|0);
                  if ($816) {
                   $$3$i$i = 0;
                   break;
                  } else {
                   $$1291$i$i = $815;$$1293$i$i = $811;
                  }
                 } else {
                  $$1291$i$i = $813;$$1293$i$i = $812;
                 }
                 while(1) {
                  $817 = ((($$1291$i$i)) + 20|0);
                  $818 = HEAP32[$817>>2]|0;
                  $819 = ($818|0)==(0|0);
                  if (!($819)) {
                   $$1291$i$i = $818;$$1293$i$i = $817;
                   continue;
                  }
                  $820 = ((($$1291$i$i)) + 16|0);
                  $821 = HEAP32[$820>>2]|0;
                  $822 = ($821|0)==(0|0);
                  if ($822) {
                   break;
                  } else {
                   $$1291$i$i = $821;$$1293$i$i = $820;
                  }
                 }
                 $823 = ($782>>>0)>($$1293$i$i>>>0);
                 if ($823) {
                  _abort();
                  // unreachable;
                 } else {
                  HEAP32[$$1293$i$i>>2] = 0;
                  $$3$i$i = $$1291$i$i;
                  break;
                 }
                } else {
                 $802 = ((($747)) + 8|0);
                 $803 = HEAP32[$802>>2]|0;
                 $804 = ($782>>>0)>($803>>>0);
                 if ($804) {
                  _abort();
                  // unreachable;
                 }
                 $805 = ((($803)) + 12|0);
                 $806 = HEAP32[$805>>2]|0;
                 $807 = ($806|0)==($747|0);
                 if (!($807)) {
                  _abort();
                  // unreachable;
                 }
                 $808 = ((($800)) + 8|0);
                 $809 = HEAP32[$808>>2]|0;
                 $810 = ($809|0)==($747|0);
                 if ($810) {
                  HEAP32[$805>>2] = $800;
                  HEAP32[$808>>2] = $803;
                  $$3$i$i = $800;
                  break;
                 } else {
                  _abort();
                  // unreachable;
                 }
                }
               } while(0);
               $824 = ($798|0)==(0|0);
               if ($824) {
                break;
               }
               $825 = ((($747)) + 28|0);
               $826 = HEAP32[$825>>2]|0;
               $827 = (177684 + ($826<<2)|0);
               $828 = HEAP32[$827>>2]|0;
               $829 = ($828|0)==($747|0);
               do {
                if ($829) {
                 HEAP32[$827>>2] = $$3$i$i;
                 $cond$i$i = ($$3$i$i|0)==(0|0);
                 if (!($cond$i$i)) {
                  break;
                 }
                 $830 = 1 << $826;
                 $831 = $830 ^ -1;
                 $832 = HEAP32[(177384)>>2]|0;
                 $833 = $832 & $831;
                 HEAP32[(177384)>>2] = $833;
                 break L326;
                } else {
                 $834 = HEAP32[(177396)>>2]|0;
                 $835 = ($834>>>0)>($798>>>0);
                 if ($835) {
                  _abort();
                  // unreachable;
                 } else {
                  $836 = ((($798)) + 16|0);
                  $837 = HEAP32[$836>>2]|0;
                  $838 = ($837|0)!=($747|0);
                  $$sink1$i$i = $838&1;
                  $839 = (((($798)) + 16|0) + ($$sink1$i$i<<2)|0);
                  HEAP32[$839>>2] = $$3$i$i;
                  $840 = ($$3$i$i|0)==(0|0);
                  if ($840) {
                   break L326;
                  } else {
                   break;
                  }
                 }
                }
               } while(0);
               $841 = HEAP32[(177396)>>2]|0;
               $842 = ($841>>>0)>($$3$i$i>>>0);
               if ($842) {
                _abort();
                // unreachable;
               }
               $843 = ((($$3$i$i)) + 24|0);
               HEAP32[$843>>2] = $798;
               $844 = ((($747)) + 16|0);
               $845 = HEAP32[$844>>2]|0;
               $846 = ($845|0)==(0|0);
               do {
                if (!($846)) {
                 $847 = ($841>>>0)>($845>>>0);
                 if ($847) {
                  _abort();
                  // unreachable;
                 } else {
                  $848 = ((($$3$i$i)) + 16|0);
                  HEAP32[$848>>2] = $845;
                  $849 = ((($845)) + 24|0);
                  HEAP32[$849>>2] = $$3$i$i;
                  break;
                 }
                }
               } while(0);
               $850 = ((($844)) + 4|0);
               $851 = HEAP32[$850>>2]|0;
               $852 = ($851|0)==(0|0);
               if ($852) {
                break;
               }
               $853 = HEAP32[(177396)>>2]|0;
               $854 = ($853>>>0)>($851>>>0);
               if ($854) {
                _abort();
                // unreachable;
               } else {
                $855 = ((($$3$i$i)) + 20|0);
                HEAP32[$855>>2] = $851;
                $856 = ((($851)) + 24|0);
                HEAP32[$856>>2] = $$3$i$i;
                break;
               }
              }
             } while(0);
             $857 = (($747) + ($771)|0);
             $858 = (($771) + ($752))|0;
             $$0$i17$i = $857;$$0287$i$i = $858;
            } else {
             $$0$i17$i = $747;$$0287$i$i = $752;
            }
            $859 = ((($$0$i17$i)) + 4|0);
            $860 = HEAP32[$859>>2]|0;
            $861 = $860 & -2;
            HEAP32[$859>>2] = $861;
            $862 = $$0287$i$i | 1;
            $863 = ((($751)) + 4|0);
            HEAP32[$863>>2] = $862;
            $864 = (($751) + ($$0287$i$i)|0);
            HEAP32[$864>>2] = $$0287$i$i;
            $865 = $$0287$i$i >>> 3;
            $866 = ($$0287$i$i>>>0)<(256);
            if ($866) {
             $867 = $865 << 1;
             $868 = (177420 + ($867<<2)|0);
             $869 = HEAP32[44345]|0;
             $870 = 1 << $865;
             $871 = $869 & $870;
             $872 = ($871|0)==(0);
             do {
              if ($872) {
               $873 = $869 | $870;
               HEAP32[44345] = $873;
               $$pre$i$i = ((($868)) + 8|0);
               $$0295$i$i = $868;$$pre$phi$i$iZ2D = $$pre$i$i;
              } else {
               $874 = ((($868)) + 8|0);
               $875 = HEAP32[$874>>2]|0;
               $876 = HEAP32[(177396)>>2]|0;
               $877 = ($876>>>0)>($875>>>0);
               if (!($877)) {
                $$0295$i$i = $875;$$pre$phi$i$iZ2D = $874;
                break;
               }
               _abort();
               // unreachable;
              }
             } while(0);
             HEAP32[$$pre$phi$i$iZ2D>>2] = $751;
             $878 = ((($$0295$i$i)) + 12|0);
             HEAP32[$878>>2] = $751;
             $879 = ((($751)) + 8|0);
             HEAP32[$879>>2] = $$0295$i$i;
             $880 = ((($751)) + 12|0);
             HEAP32[$880>>2] = $868;
             break;
            }
            $881 = $$0287$i$i >>> 8;
            $882 = ($881|0)==(0);
            do {
             if ($882) {
              $$0296$i$i = 0;
             } else {
              $883 = ($$0287$i$i>>>0)>(16777215);
              if ($883) {
               $$0296$i$i = 31;
               break;
              }
              $884 = (($881) + 1048320)|0;
              $885 = $884 >>> 16;
              $886 = $885 & 8;
              $887 = $881 << $886;
              $888 = (($887) + 520192)|0;
              $889 = $888 >>> 16;
              $890 = $889 & 4;
              $891 = $890 | $886;
              $892 = $887 << $890;
              $893 = (($892) + 245760)|0;
              $894 = $893 >>> 16;
              $895 = $894 & 2;
              $896 = $891 | $895;
              $897 = (14 - ($896))|0;
              $898 = $892 << $895;
              $899 = $898 >>> 15;
              $900 = (($897) + ($899))|0;
              $901 = $900 << 1;
              $902 = (($900) + 7)|0;
              $903 = $$0287$i$i >>> $902;
              $904 = $903 & 1;
              $905 = $904 | $901;
              $$0296$i$i = $905;
             }
            } while(0);
            $906 = (177684 + ($$0296$i$i<<2)|0);
            $907 = ((($751)) + 28|0);
            HEAP32[$907>>2] = $$0296$i$i;
            $908 = ((($751)) + 16|0);
            $909 = ((($908)) + 4|0);
            HEAP32[$909>>2] = 0;
            HEAP32[$908>>2] = 0;
            $910 = HEAP32[(177384)>>2]|0;
            $911 = 1 << $$0296$i$i;
            $912 = $910 & $911;
            $913 = ($912|0)==(0);
            if ($913) {
             $914 = $910 | $911;
             HEAP32[(177384)>>2] = $914;
             HEAP32[$906>>2] = $751;
             $915 = ((($751)) + 24|0);
             HEAP32[$915>>2] = $906;
             $916 = ((($751)) + 12|0);
             HEAP32[$916>>2] = $751;
             $917 = ((($751)) + 8|0);
             HEAP32[$917>>2] = $751;
             break;
            }
            $918 = HEAP32[$906>>2]|0;
            $919 = ($$0296$i$i|0)==(31);
            $920 = $$0296$i$i >>> 1;
            $921 = (25 - ($920))|0;
            $922 = $919 ? 0 : $921;
            $923 = $$0287$i$i << $922;
            $$0288$i$i = $923;$$0289$i$i = $918;
            while(1) {
             $924 = ((($$0289$i$i)) + 4|0);
             $925 = HEAP32[$924>>2]|0;
             $926 = $925 & -8;
             $927 = ($926|0)==($$0287$i$i|0);
             if ($927) {
              label = 278;
              break;
             }
             $928 = $$0288$i$i >>> 31;
             $929 = (((($$0289$i$i)) + 16|0) + ($928<<2)|0);
             $930 = $$0288$i$i << 1;
             $931 = HEAP32[$929>>2]|0;
             $932 = ($931|0)==(0|0);
             if ($932) {
              label = 275;
              break;
             } else {
              $$0288$i$i = $930;$$0289$i$i = $931;
             }
            }
            if ((label|0) == 275) {
             $933 = HEAP32[(177396)>>2]|0;
             $934 = ($933>>>0)>($929>>>0);
             if ($934) {
              _abort();
              // unreachable;
             } else {
              HEAP32[$929>>2] = $751;
              $935 = ((($751)) + 24|0);
              HEAP32[$935>>2] = $$0289$i$i;
              $936 = ((($751)) + 12|0);
              HEAP32[$936>>2] = $751;
              $937 = ((($751)) + 8|0);
              HEAP32[$937>>2] = $751;
              break;
             }
            }
            else if ((label|0) == 278) {
             $938 = ((($$0289$i$i)) + 8|0);
             $939 = HEAP32[$938>>2]|0;
             $940 = HEAP32[(177396)>>2]|0;
             $941 = ($940>>>0)<=($$0289$i$i>>>0);
             $942 = ($940>>>0)<=($939>>>0);
             $943 = $942 & $941;
             if ($943) {
              $944 = ((($939)) + 12|0);
              HEAP32[$944>>2] = $751;
              HEAP32[$938>>2] = $751;
              $945 = ((($751)) + 8|0);
              HEAP32[$945>>2] = $939;
              $946 = ((($751)) + 12|0);
              HEAP32[$946>>2] = $$0289$i$i;
              $947 = ((($751)) + 24|0);
              HEAP32[$947>>2] = 0;
              break;
             } else {
              _abort();
              // unreachable;
             }
            }
           }
          } while(0);
          $1080 = ((($739)) + 8|0);
          $$2 = $1080;
          break L230;
         } else {
          $$0$i$i$i = (177856);
         }
        }
        while(1) {
         $948 = HEAP32[$$0$i$i$i>>2]|0;
         $949 = ($948>>>0)>($665>>>0);
         if (!($949)) {
          $950 = ((($$0$i$i$i)) + 4|0);
          $951 = HEAP32[$950>>2]|0;
          $952 = (($948) + ($951)|0);
          $953 = ($952>>>0)>($665>>>0);
          if ($953) {
           break;
          }
         }
         $954 = ((($$0$i$i$i)) + 8|0);
         $955 = HEAP32[$954>>2]|0;
         $$0$i$i$i = $955;
        }
        $956 = ((($952)) + -47|0);
        $957 = ((($956)) + 8|0);
        $958 = $957;
        $959 = $958 & 7;
        $960 = ($959|0)==(0);
        $961 = (0 - ($958))|0;
        $962 = $961 & 7;
        $963 = $960 ? 0 : $962;
        $964 = (($956) + ($963)|0);
        $965 = ((($665)) + 16|0);
        $966 = ($964>>>0)<($965>>>0);
        $967 = $966 ? $665 : $964;
        $968 = ((($967)) + 8|0);
        $969 = ((($967)) + 24|0);
        $970 = (($$7239$i) + -40)|0;
        $971 = ((($$7$i)) + 8|0);
        $972 = $971;
        $973 = $972 & 7;
        $974 = ($973|0)==(0);
        $975 = (0 - ($972))|0;
        $976 = $975 & 7;
        $977 = $974 ? 0 : $976;
        $978 = (($$7$i) + ($977)|0);
        $979 = (($970) - ($977))|0;
        HEAP32[(177404)>>2] = $978;
        HEAP32[(177392)>>2] = $979;
        $980 = $979 | 1;
        $981 = ((($978)) + 4|0);
        HEAP32[$981>>2] = $980;
        $982 = (($$7$i) + ($970)|0);
        $983 = ((($982)) + 4|0);
        HEAP32[$983>>2] = 40;
        $984 = HEAP32[(177344)>>2]|0;
        HEAP32[(177408)>>2] = $984;
        $985 = ((($967)) + 4|0);
        HEAP32[$985>>2] = 27;
        ;HEAP32[$968>>2]=HEAP32[(177856)>>2]|0;HEAP32[$968+4>>2]=HEAP32[(177856)+4>>2]|0;HEAP32[$968+8>>2]=HEAP32[(177856)+8>>2]|0;HEAP32[$968+12>>2]=HEAP32[(177856)+12>>2]|0;
        HEAP32[(177856)>>2] = $$7$i;
        HEAP32[(177860)>>2] = $$7239$i;
        HEAP32[(177868)>>2] = 0;
        HEAP32[(177864)>>2] = $968;
        $987 = $969;
        while(1) {
         $986 = ((($987)) + 4|0);
         HEAP32[$986>>2] = 7;
         $988 = ((($987)) + 8|0);
         $989 = ($988>>>0)<($952>>>0);
         if ($989) {
          $987 = $986;
         } else {
          break;
         }
        }
        $990 = ($967|0)==($665|0);
        if (!($990)) {
         $991 = $967;
         $992 = $665;
         $993 = (($991) - ($992))|0;
         $994 = HEAP32[$985>>2]|0;
         $995 = $994 & -2;
         HEAP32[$985>>2] = $995;
         $996 = $993 | 1;
         $997 = ((($665)) + 4|0);
         HEAP32[$997>>2] = $996;
         HEAP32[$967>>2] = $993;
         $998 = $993 >>> 3;
         $999 = ($993>>>0)<(256);
         if ($999) {
          $1000 = $998 << 1;
          $1001 = (177420 + ($1000<<2)|0);
          $1002 = HEAP32[44345]|0;
          $1003 = 1 << $998;
          $1004 = $1002 & $1003;
          $1005 = ($1004|0)==(0);
          do {
           if ($1005) {
            $1006 = $1002 | $1003;
            HEAP32[44345] = $1006;
            $$pre$i18$i = ((($1001)) + 8|0);
            $$0211$i$i = $1001;$$pre$phi$i19$iZ2D = $$pre$i18$i;
           } else {
            $1007 = ((($1001)) + 8|0);
            $1008 = HEAP32[$1007>>2]|0;
            $1009 = HEAP32[(177396)>>2]|0;
            $1010 = ($1009>>>0)>($1008>>>0);
            if (!($1010)) {
             $$0211$i$i = $1008;$$pre$phi$i19$iZ2D = $1007;
             break;
            }
            _abort();
            // unreachable;
           }
          } while(0);
          HEAP32[$$pre$phi$i19$iZ2D>>2] = $665;
          $1011 = ((($$0211$i$i)) + 12|0);
          HEAP32[$1011>>2] = $665;
          $1012 = ((($665)) + 8|0);
          HEAP32[$1012>>2] = $$0211$i$i;
          $1013 = ((($665)) + 12|0);
          HEAP32[$1013>>2] = $1001;
          break;
         }
         $1014 = $993 >>> 8;
         $1015 = ($1014|0)==(0);
         do {
          if ($1015) {
           $$0212$i$i = 0;
          } else {
           $1016 = ($993>>>0)>(16777215);
           if ($1016) {
            $$0212$i$i = 31;
            break;
           }
           $1017 = (($1014) + 1048320)|0;
           $1018 = $1017 >>> 16;
           $1019 = $1018 & 8;
           $1020 = $1014 << $1019;
           $1021 = (($1020) + 520192)|0;
           $1022 = $1021 >>> 16;
           $1023 = $1022 & 4;
           $1024 = $1023 | $1019;
           $1025 = $1020 << $1023;
           $1026 = (($1025) + 245760)|0;
           $1027 = $1026 >>> 16;
           $1028 = $1027 & 2;
           $1029 = $1024 | $1028;
           $1030 = (14 - ($1029))|0;
           $1031 = $1025 << $1028;
           $1032 = $1031 >>> 15;
           $1033 = (($1030) + ($1032))|0;
           $1034 = $1033 << 1;
           $1035 = (($1033) + 7)|0;
           $1036 = $993 >>> $1035;
           $1037 = $1036 & 1;
           $1038 = $1037 | $1034;
           $$0212$i$i = $1038;
          }
         } while(0);
         $1039 = (177684 + ($$0212$i$i<<2)|0);
         $1040 = ((($665)) + 28|0);
         HEAP32[$1040>>2] = $$0212$i$i;
         $1041 = ((($665)) + 20|0);
         HEAP32[$1041>>2] = 0;
         HEAP32[$965>>2] = 0;
         $1042 = HEAP32[(177384)>>2]|0;
         $1043 = 1 << $$0212$i$i;
         $1044 = $1042 & $1043;
         $1045 = ($1044|0)==(0);
         if ($1045) {
          $1046 = $1042 | $1043;
          HEAP32[(177384)>>2] = $1046;
          HEAP32[$1039>>2] = $665;
          $1047 = ((($665)) + 24|0);
          HEAP32[$1047>>2] = $1039;
          $1048 = ((($665)) + 12|0);
          HEAP32[$1048>>2] = $665;
          $1049 = ((($665)) + 8|0);
          HEAP32[$1049>>2] = $665;
          break;
         }
         $1050 = HEAP32[$1039>>2]|0;
         $1051 = ($$0212$i$i|0)==(31);
         $1052 = $$0212$i$i >>> 1;
         $1053 = (25 - ($1052))|0;
         $1054 = $1051 ? 0 : $1053;
         $1055 = $993 << $1054;
         $$0206$i$i = $1055;$$0207$i$i = $1050;
         while(1) {
          $1056 = ((($$0207$i$i)) + 4|0);
          $1057 = HEAP32[$1056>>2]|0;
          $1058 = $1057 & -8;
          $1059 = ($1058|0)==($993|0);
          if ($1059) {
           label = 304;
           break;
          }
          $1060 = $$0206$i$i >>> 31;
          $1061 = (((($$0207$i$i)) + 16|0) + ($1060<<2)|0);
          $1062 = $$0206$i$i << 1;
          $1063 = HEAP32[$1061>>2]|0;
          $1064 = ($1063|0)==(0|0);
          if ($1064) {
           label = 301;
           break;
          } else {
           $$0206$i$i = $1062;$$0207$i$i = $1063;
          }
         }
         if ((label|0) == 301) {
          $1065 = HEAP32[(177396)>>2]|0;
          $1066 = ($1065>>>0)>($1061>>>0);
          if ($1066) {
           _abort();
           // unreachable;
          } else {
           HEAP32[$1061>>2] = $665;
           $1067 = ((($665)) + 24|0);
           HEAP32[$1067>>2] = $$0207$i$i;
           $1068 = ((($665)) + 12|0);
           HEAP32[$1068>>2] = $665;
           $1069 = ((($665)) + 8|0);
           HEAP32[$1069>>2] = $665;
           break;
          }
         }
         else if ((label|0) == 304) {
          $1070 = ((($$0207$i$i)) + 8|0);
          $1071 = HEAP32[$1070>>2]|0;
          $1072 = HEAP32[(177396)>>2]|0;
          $1073 = ($1072>>>0)<=($$0207$i$i>>>0);
          $1074 = ($1072>>>0)<=($1071>>>0);
          $1075 = $1074 & $1073;
          if ($1075) {
           $1076 = ((($1071)) + 12|0);
           HEAP32[$1076>>2] = $665;
           HEAP32[$1070>>2] = $665;
           $1077 = ((($665)) + 8|0);
           HEAP32[$1077>>2] = $1071;
           $1078 = ((($665)) + 12|0);
           HEAP32[$1078>>2] = $$0207$i$i;
           $1079 = ((($665)) + 24|0);
           HEAP32[$1079>>2] = 0;
           break;
          } else {
           _abort();
           // unreachable;
          }
         }
        }
       }
      } while(0);
      $1081 = HEAP32[(177392)>>2]|0;
      $1082 = ($1081>>>0)>($$0198>>>0);
      if ($1082) {
       $1083 = (($1081) - ($$0198))|0;
       HEAP32[(177392)>>2] = $1083;
       $1084 = HEAP32[(177404)>>2]|0;
       $1085 = (($1084) + ($$0198)|0);
       HEAP32[(177404)>>2] = $1085;
       $1086 = $1083 | 1;
       $1087 = ((($1085)) + 4|0);
       HEAP32[$1087>>2] = $1086;
       $1088 = $$0198 | 3;
       $1089 = ((($1084)) + 4|0);
       HEAP32[$1089>>2] = $1088;
       $1090 = ((($1084)) + 8|0);
       $$2 = $1090;
       break;
      }
     }
    }
    $1091 = (___errno_location()|0);
    HEAP32[$1091>>2] = 12;
    $$2 = 0;
   } else {
    $$2 = 0;
   }
  }
 } while(0);
 $1092 = HEAP32[(177824)>>2]|0;
 $1093 = $1092 & 2;
 $1094 = ($1093|0)==(0);
 if ($1094) {
  $$1 = $$2;
  STACKTOP = sp;return ($$1|0);
 }
 (___pthread_mutex_unlock((177828))|0);
 $$1 = $$2;
 STACKTOP = sp;return ($$1|0);
}
function _free($0) {
 $0 = $0|0;
 var $$0212$i = 0, $$0212$in$i = 0, $$0383 = 0, $$0384 = 0, $$0396 = 0, $$0403 = 0, $$1 = 0, $$1382 = 0, $$1387 = 0, $$1390 = 0, $$1398 = 0, $$1402 = 0, $$2 = 0, $$3 = 0, $$3400 = 0, $$pre = 0, $$pre$phi442Z2D = 0, $$pre$phi444Z2D = 0, $$pre$phiZ2D = 0, $$pre441 = 0;
 var $$pre443 = 0, $$sink3 = 0, $$sink5 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0;
 var $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0;
 var $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0;
 var $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0;
 var $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0;
 var $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0;
 var $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0;
 var $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0;
 var $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0;
 var $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0;
 var $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0;
 var $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0;
 var $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0;
 var $330 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0;
 var $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0;
 var $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0;
 var $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $cond421 = 0, $cond422 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = ($0|0)==(0|0);
 if ($1) {
  return;
 }
 $2 = ((($0)) + -8|0);
 $3 = HEAP32[(177824)>>2]|0;
 $4 = $3 & 2;
 $5 = ($4|0)==(0);
 if (!($5)) {
  $6 = (___pthread_mutex_lock((177828))|0);
  $7 = ($6|0)==(0);
  if (!($7)) {
   return;
  }
 }
 $8 = HEAP32[(177396)>>2]|0;
 $9 = ($2>>>0)<($8>>>0);
 if ($9) {
  _abort();
  // unreachable;
 }
 $10 = ((($0)) + -4|0);
 $11 = HEAP32[$10>>2]|0;
 $12 = $11 & 3;
 $13 = ($12|0)==(1);
 if ($13) {
  _abort();
  // unreachable;
 }
 $14 = $11 & -8;
 $15 = (($2) + ($14)|0);
 $16 = $11 & 1;
 $17 = ($16|0)==(0);
 L14: do {
  if ($17) {
   $18 = HEAP32[$2>>2]|0;
   $19 = ($12|0)==(0);
   if (!($19)) {
    $20 = (0 - ($18))|0;
    $21 = (($2) + ($20)|0);
    $22 = (($18) + ($14))|0;
    $23 = ($21>>>0)<($8>>>0);
    if ($23) {
     _abort();
     // unreachable;
    }
    $24 = HEAP32[(177400)>>2]|0;
    $25 = ($24|0)==($21|0);
    if ($25) {
     $110 = ((($15)) + 4|0);
     $111 = HEAP32[$110>>2]|0;
     $112 = $111 & 3;
     $113 = ($112|0)==(3);
     if (!($113)) {
      $$1 = $21;$$1382 = $22;$119 = $21;
      label = 55;
      break;
     }
     HEAP32[(177388)>>2] = $22;
     $114 = $111 & -2;
     HEAP32[$110>>2] = $114;
     $115 = $22 | 1;
     $116 = ((($21)) + 4|0);
     HEAP32[$116>>2] = $115;
     $117 = (($21) + ($22)|0);
     HEAP32[$117>>2] = $22;
     break;
    }
    $26 = $18 >>> 3;
    $27 = ($18>>>0)<(256);
    if ($27) {
     $28 = ((($21)) + 8|0);
     $29 = HEAP32[$28>>2]|0;
     $30 = ((($21)) + 12|0);
     $31 = HEAP32[$30>>2]|0;
     $32 = $26 << 1;
     $33 = (177420 + ($32<<2)|0);
     $34 = ($29|0)==($33|0);
     if (!($34)) {
      $35 = ($8>>>0)>($29>>>0);
      if ($35) {
       _abort();
       // unreachable;
      }
      $36 = ((($29)) + 12|0);
      $37 = HEAP32[$36>>2]|0;
      $38 = ($37|0)==($21|0);
      if (!($38)) {
       _abort();
       // unreachable;
      }
     }
     $39 = ($31|0)==($29|0);
     if ($39) {
      $40 = 1 << $26;
      $41 = $40 ^ -1;
      $42 = HEAP32[44345]|0;
      $43 = $42 & $41;
      HEAP32[44345] = $43;
      $$1 = $21;$$1382 = $22;$119 = $21;
      label = 55;
      break;
     }
     $44 = ($31|0)==($33|0);
     if ($44) {
      $$pre443 = ((($31)) + 8|0);
      $$pre$phi444Z2D = $$pre443;
     } else {
      $45 = ($8>>>0)>($31>>>0);
      if ($45) {
       _abort();
       // unreachable;
      }
      $46 = ((($31)) + 8|0);
      $47 = HEAP32[$46>>2]|0;
      $48 = ($47|0)==($21|0);
      if ($48) {
       $$pre$phi444Z2D = $46;
      } else {
       _abort();
       // unreachable;
      }
     }
     $49 = ((($29)) + 12|0);
     HEAP32[$49>>2] = $31;
     HEAP32[$$pre$phi444Z2D>>2] = $29;
     $$1 = $21;$$1382 = $22;$119 = $21;
     label = 55;
     break;
    }
    $50 = ((($21)) + 24|0);
    $51 = HEAP32[$50>>2]|0;
    $52 = ((($21)) + 12|0);
    $53 = HEAP32[$52>>2]|0;
    $54 = ($53|0)==($21|0);
    do {
     if ($54) {
      $64 = ((($21)) + 16|0);
      $65 = ((($64)) + 4|0);
      $66 = HEAP32[$65>>2]|0;
      $67 = ($66|0)==(0|0);
      if ($67) {
       $68 = HEAP32[$64>>2]|0;
       $69 = ($68|0)==(0|0);
       if ($69) {
        $$3 = 0;
        break;
       } else {
        $$1387 = $68;$$1390 = $64;
       }
      } else {
       $$1387 = $66;$$1390 = $65;
      }
      while(1) {
       $70 = ((($$1387)) + 20|0);
       $71 = HEAP32[$70>>2]|0;
       $72 = ($71|0)==(0|0);
       if (!($72)) {
        $$1387 = $71;$$1390 = $70;
        continue;
       }
       $73 = ((($$1387)) + 16|0);
       $74 = HEAP32[$73>>2]|0;
       $75 = ($74|0)==(0|0);
       if ($75) {
        break;
       } else {
        $$1387 = $74;$$1390 = $73;
       }
      }
      $76 = ($8>>>0)>($$1390>>>0);
      if ($76) {
       _abort();
       // unreachable;
      } else {
       HEAP32[$$1390>>2] = 0;
       $$3 = $$1387;
       break;
      }
     } else {
      $55 = ((($21)) + 8|0);
      $56 = HEAP32[$55>>2]|0;
      $57 = ($8>>>0)>($56>>>0);
      if ($57) {
       _abort();
       // unreachable;
      }
      $58 = ((($56)) + 12|0);
      $59 = HEAP32[$58>>2]|0;
      $60 = ($59|0)==($21|0);
      if (!($60)) {
       _abort();
       // unreachable;
      }
      $61 = ((($53)) + 8|0);
      $62 = HEAP32[$61>>2]|0;
      $63 = ($62|0)==($21|0);
      if ($63) {
       HEAP32[$58>>2] = $53;
       HEAP32[$61>>2] = $56;
       $$3 = $53;
       break;
      } else {
       _abort();
       // unreachable;
      }
     }
    } while(0);
    $77 = ($51|0)==(0|0);
    if ($77) {
     $$1 = $21;$$1382 = $22;$119 = $21;
     label = 55;
    } else {
     $78 = ((($21)) + 28|0);
     $79 = HEAP32[$78>>2]|0;
     $80 = (177684 + ($79<<2)|0);
     $81 = HEAP32[$80>>2]|0;
     $82 = ($81|0)==($21|0);
     do {
      if ($82) {
       HEAP32[$80>>2] = $$3;
       $cond421 = ($$3|0)==(0|0);
       if ($cond421) {
        $83 = 1 << $79;
        $84 = $83 ^ -1;
        $85 = HEAP32[(177384)>>2]|0;
        $86 = $85 & $84;
        HEAP32[(177384)>>2] = $86;
        $$1 = $21;$$1382 = $22;$119 = $21;
        label = 55;
        break L14;
       }
      } else {
       $87 = HEAP32[(177396)>>2]|0;
       $88 = ($87>>>0)>($51>>>0);
       if ($88) {
        _abort();
        // unreachable;
       } else {
        $89 = ((($51)) + 16|0);
        $90 = HEAP32[$89>>2]|0;
        $91 = ($90|0)!=($21|0);
        $$sink3 = $91&1;
        $92 = (((($51)) + 16|0) + ($$sink3<<2)|0);
        HEAP32[$92>>2] = $$3;
        $93 = ($$3|0)==(0|0);
        if ($93) {
         $$1 = $21;$$1382 = $22;$119 = $21;
         label = 55;
         break L14;
        } else {
         break;
        }
       }
      }
     } while(0);
     $94 = HEAP32[(177396)>>2]|0;
     $95 = ($94>>>0)>($$3>>>0);
     if ($95) {
      _abort();
      // unreachable;
     }
     $96 = ((($$3)) + 24|0);
     HEAP32[$96>>2] = $51;
     $97 = ((($21)) + 16|0);
     $98 = HEAP32[$97>>2]|0;
     $99 = ($98|0)==(0|0);
     do {
      if (!($99)) {
       $100 = ($94>>>0)>($98>>>0);
       if ($100) {
        _abort();
        // unreachable;
       } else {
        $101 = ((($$3)) + 16|0);
        HEAP32[$101>>2] = $98;
        $102 = ((($98)) + 24|0);
        HEAP32[$102>>2] = $$3;
        break;
       }
      }
     } while(0);
     $103 = ((($97)) + 4|0);
     $104 = HEAP32[$103>>2]|0;
     $105 = ($104|0)==(0|0);
     if ($105) {
      $$1 = $21;$$1382 = $22;$119 = $21;
      label = 55;
     } else {
      $106 = HEAP32[(177396)>>2]|0;
      $107 = ($106>>>0)>($104>>>0);
      if ($107) {
       _abort();
       // unreachable;
      } else {
       $108 = ((($$3)) + 20|0);
       HEAP32[$108>>2] = $104;
       $109 = ((($104)) + 24|0);
       HEAP32[$109>>2] = $$3;
       $$1 = $21;$$1382 = $22;$119 = $21;
       label = 55;
       break;
      }
     }
    }
   }
  } else {
   $$1 = $2;$$1382 = $14;$119 = $2;
   label = 55;
  }
 } while(0);
 do {
  if ((label|0) == 55) {
   $118 = ($119>>>0)<($15>>>0);
   if (!($118)) {
    _abort();
    // unreachable;
   }
   $120 = ((($15)) + 4|0);
   $121 = HEAP32[$120>>2]|0;
   $122 = $121 & 1;
   $123 = ($122|0)==(0);
   if ($123) {
    _abort();
    // unreachable;
   }
   $124 = $121 & 2;
   $125 = ($124|0)==(0);
   if ($125) {
    $126 = HEAP32[(177404)>>2]|0;
    $127 = ($126|0)==($15|0);
    if ($127) {
     $128 = HEAP32[(177392)>>2]|0;
     $129 = (($128) + ($$1382))|0;
     HEAP32[(177392)>>2] = $129;
     HEAP32[(177404)>>2] = $$1;
     $130 = $129 | 1;
     $131 = ((($$1)) + 4|0);
     HEAP32[$131>>2] = $130;
     $132 = HEAP32[(177400)>>2]|0;
     $133 = ($$1|0)==($132|0);
     if (!($133)) {
      break;
     }
     HEAP32[(177400)>>2] = 0;
     HEAP32[(177388)>>2] = 0;
     break;
    }
    $134 = HEAP32[(177400)>>2]|0;
    $135 = ($134|0)==($15|0);
    if ($135) {
     $136 = HEAP32[(177388)>>2]|0;
     $137 = (($136) + ($$1382))|0;
     HEAP32[(177388)>>2] = $137;
     HEAP32[(177400)>>2] = $119;
     $138 = $137 | 1;
     $139 = ((($$1)) + 4|0);
     HEAP32[$139>>2] = $138;
     $140 = (($119) + ($137)|0);
     HEAP32[$140>>2] = $137;
     break;
    }
    $141 = $121 & -8;
    $142 = (($141) + ($$1382))|0;
    $143 = $121 >>> 3;
    $144 = ($121>>>0)<(256);
    L106: do {
     if ($144) {
      $145 = ((($15)) + 8|0);
      $146 = HEAP32[$145>>2]|0;
      $147 = ((($15)) + 12|0);
      $148 = HEAP32[$147>>2]|0;
      $149 = $143 << 1;
      $150 = (177420 + ($149<<2)|0);
      $151 = ($146|0)==($150|0);
      if (!($151)) {
       $152 = HEAP32[(177396)>>2]|0;
       $153 = ($152>>>0)>($146>>>0);
       if ($153) {
        _abort();
        // unreachable;
       }
       $154 = ((($146)) + 12|0);
       $155 = HEAP32[$154>>2]|0;
       $156 = ($155|0)==($15|0);
       if (!($156)) {
        _abort();
        // unreachable;
       }
      }
      $157 = ($148|0)==($146|0);
      if ($157) {
       $158 = 1 << $143;
       $159 = $158 ^ -1;
       $160 = HEAP32[44345]|0;
       $161 = $160 & $159;
       HEAP32[44345] = $161;
       break;
      }
      $162 = ($148|0)==($150|0);
      if ($162) {
       $$pre441 = ((($148)) + 8|0);
       $$pre$phi442Z2D = $$pre441;
      } else {
       $163 = HEAP32[(177396)>>2]|0;
       $164 = ($163>>>0)>($148>>>0);
       if ($164) {
        _abort();
        // unreachable;
       }
       $165 = ((($148)) + 8|0);
       $166 = HEAP32[$165>>2]|0;
       $167 = ($166|0)==($15|0);
       if ($167) {
        $$pre$phi442Z2D = $165;
       } else {
        _abort();
        // unreachable;
       }
      }
      $168 = ((($146)) + 12|0);
      HEAP32[$168>>2] = $148;
      HEAP32[$$pre$phi442Z2D>>2] = $146;
     } else {
      $169 = ((($15)) + 24|0);
      $170 = HEAP32[$169>>2]|0;
      $171 = ((($15)) + 12|0);
      $172 = HEAP32[$171>>2]|0;
      $173 = ($172|0)==($15|0);
      do {
       if ($173) {
        $184 = ((($15)) + 16|0);
        $185 = ((($184)) + 4|0);
        $186 = HEAP32[$185>>2]|0;
        $187 = ($186|0)==(0|0);
        if ($187) {
         $188 = HEAP32[$184>>2]|0;
         $189 = ($188|0)==(0|0);
         if ($189) {
          $$3400 = 0;
          break;
         } else {
          $$1398 = $188;$$1402 = $184;
         }
        } else {
         $$1398 = $186;$$1402 = $185;
        }
        while(1) {
         $190 = ((($$1398)) + 20|0);
         $191 = HEAP32[$190>>2]|0;
         $192 = ($191|0)==(0|0);
         if (!($192)) {
          $$1398 = $191;$$1402 = $190;
          continue;
         }
         $193 = ((($$1398)) + 16|0);
         $194 = HEAP32[$193>>2]|0;
         $195 = ($194|0)==(0|0);
         if ($195) {
          break;
         } else {
          $$1398 = $194;$$1402 = $193;
         }
        }
        $196 = HEAP32[(177396)>>2]|0;
        $197 = ($196>>>0)>($$1402>>>0);
        if ($197) {
         _abort();
         // unreachable;
        } else {
         HEAP32[$$1402>>2] = 0;
         $$3400 = $$1398;
         break;
        }
       } else {
        $174 = ((($15)) + 8|0);
        $175 = HEAP32[$174>>2]|0;
        $176 = HEAP32[(177396)>>2]|0;
        $177 = ($176>>>0)>($175>>>0);
        if ($177) {
         _abort();
         // unreachable;
        }
        $178 = ((($175)) + 12|0);
        $179 = HEAP32[$178>>2]|0;
        $180 = ($179|0)==($15|0);
        if (!($180)) {
         _abort();
         // unreachable;
        }
        $181 = ((($172)) + 8|0);
        $182 = HEAP32[$181>>2]|0;
        $183 = ($182|0)==($15|0);
        if ($183) {
         HEAP32[$178>>2] = $172;
         HEAP32[$181>>2] = $175;
         $$3400 = $172;
         break;
        } else {
         _abort();
         // unreachable;
        }
       }
      } while(0);
      $198 = ($170|0)==(0|0);
      if (!($198)) {
       $199 = ((($15)) + 28|0);
       $200 = HEAP32[$199>>2]|0;
       $201 = (177684 + ($200<<2)|0);
       $202 = HEAP32[$201>>2]|0;
       $203 = ($202|0)==($15|0);
       do {
        if ($203) {
         HEAP32[$201>>2] = $$3400;
         $cond422 = ($$3400|0)==(0|0);
         if ($cond422) {
          $204 = 1 << $200;
          $205 = $204 ^ -1;
          $206 = HEAP32[(177384)>>2]|0;
          $207 = $206 & $205;
          HEAP32[(177384)>>2] = $207;
          break L106;
         }
        } else {
         $208 = HEAP32[(177396)>>2]|0;
         $209 = ($208>>>0)>($170>>>0);
         if ($209) {
          _abort();
          // unreachable;
         } else {
          $210 = ((($170)) + 16|0);
          $211 = HEAP32[$210>>2]|0;
          $212 = ($211|0)!=($15|0);
          $$sink5 = $212&1;
          $213 = (((($170)) + 16|0) + ($$sink5<<2)|0);
          HEAP32[$213>>2] = $$3400;
          $214 = ($$3400|0)==(0|0);
          if ($214) {
           break L106;
          } else {
           break;
          }
         }
        }
       } while(0);
       $215 = HEAP32[(177396)>>2]|0;
       $216 = ($215>>>0)>($$3400>>>0);
       if ($216) {
        _abort();
        // unreachable;
       }
       $217 = ((($$3400)) + 24|0);
       HEAP32[$217>>2] = $170;
       $218 = ((($15)) + 16|0);
       $219 = HEAP32[$218>>2]|0;
       $220 = ($219|0)==(0|0);
       do {
        if (!($220)) {
         $221 = ($215>>>0)>($219>>>0);
         if ($221) {
          _abort();
          // unreachable;
         } else {
          $222 = ((($$3400)) + 16|0);
          HEAP32[$222>>2] = $219;
          $223 = ((($219)) + 24|0);
          HEAP32[$223>>2] = $$3400;
          break;
         }
        }
       } while(0);
       $224 = ((($218)) + 4|0);
       $225 = HEAP32[$224>>2]|0;
       $226 = ($225|0)==(0|0);
       if (!($226)) {
        $227 = HEAP32[(177396)>>2]|0;
        $228 = ($227>>>0)>($225>>>0);
        if ($228) {
         _abort();
         // unreachable;
        } else {
         $229 = ((($$3400)) + 20|0);
         HEAP32[$229>>2] = $225;
         $230 = ((($225)) + 24|0);
         HEAP32[$230>>2] = $$3400;
         break;
        }
       }
      }
     }
    } while(0);
    $231 = $142 | 1;
    $232 = ((($$1)) + 4|0);
    HEAP32[$232>>2] = $231;
    $233 = (($119) + ($142)|0);
    HEAP32[$233>>2] = $142;
    $234 = HEAP32[(177400)>>2]|0;
    $235 = ($$1|0)==($234|0);
    if ($235) {
     HEAP32[(177388)>>2] = $142;
     break;
    } else {
     $$2 = $142;
    }
   } else {
    $236 = $121 & -2;
    HEAP32[$120>>2] = $236;
    $237 = $$1382 | 1;
    $238 = ((($$1)) + 4|0);
    HEAP32[$238>>2] = $237;
    $239 = (($119) + ($$1382)|0);
    HEAP32[$239>>2] = $$1382;
    $$2 = $$1382;
   }
   $240 = $$2 >>> 3;
   $241 = ($$2>>>0)<(256);
   if ($241) {
    $242 = $240 << 1;
    $243 = (177420 + ($242<<2)|0);
    $244 = HEAP32[44345]|0;
    $245 = 1 << $240;
    $246 = $244 & $245;
    $247 = ($246|0)==(0);
    if ($247) {
     $248 = $244 | $245;
     HEAP32[44345] = $248;
     $$pre = ((($243)) + 8|0);
     $$0403 = $243;$$pre$phiZ2D = $$pre;
    } else {
     $249 = ((($243)) + 8|0);
     $250 = HEAP32[$249>>2]|0;
     $251 = HEAP32[(177396)>>2]|0;
     $252 = ($251>>>0)>($250>>>0);
     if ($252) {
      _abort();
      // unreachable;
     } else {
      $$0403 = $250;$$pre$phiZ2D = $249;
     }
    }
    HEAP32[$$pre$phiZ2D>>2] = $$1;
    $253 = ((($$0403)) + 12|0);
    HEAP32[$253>>2] = $$1;
    $254 = ((($$1)) + 8|0);
    HEAP32[$254>>2] = $$0403;
    $255 = ((($$1)) + 12|0);
    HEAP32[$255>>2] = $243;
    break;
   }
   $256 = $$2 >>> 8;
   $257 = ($256|0)==(0);
   if ($257) {
    $$0396 = 0;
   } else {
    $258 = ($$2>>>0)>(16777215);
    if ($258) {
     $$0396 = 31;
    } else {
     $259 = (($256) + 1048320)|0;
     $260 = $259 >>> 16;
     $261 = $260 & 8;
     $262 = $256 << $261;
     $263 = (($262) + 520192)|0;
     $264 = $263 >>> 16;
     $265 = $264 & 4;
     $266 = $265 | $261;
     $267 = $262 << $265;
     $268 = (($267) + 245760)|0;
     $269 = $268 >>> 16;
     $270 = $269 & 2;
     $271 = $266 | $270;
     $272 = (14 - ($271))|0;
     $273 = $267 << $270;
     $274 = $273 >>> 15;
     $275 = (($272) + ($274))|0;
     $276 = $275 << 1;
     $277 = (($275) + 7)|0;
     $278 = $$2 >>> $277;
     $279 = $278 & 1;
     $280 = $279 | $276;
     $$0396 = $280;
    }
   }
   $281 = (177684 + ($$0396<<2)|0);
   $282 = ((($$1)) + 28|0);
   HEAP32[$282>>2] = $$0396;
   $283 = ((($$1)) + 16|0);
   $284 = ((($$1)) + 20|0);
   HEAP32[$284>>2] = 0;
   HEAP32[$283>>2] = 0;
   $285 = HEAP32[(177384)>>2]|0;
   $286 = 1 << $$0396;
   $287 = $285 & $286;
   $288 = ($287|0)==(0);
   do {
    if ($288) {
     $289 = $285 | $286;
     HEAP32[(177384)>>2] = $289;
     HEAP32[$281>>2] = $$1;
     $290 = ((($$1)) + 24|0);
     HEAP32[$290>>2] = $281;
     $291 = ((($$1)) + 12|0);
     HEAP32[$291>>2] = $$1;
     $292 = ((($$1)) + 8|0);
     HEAP32[$292>>2] = $$1;
    } else {
     $293 = HEAP32[$281>>2]|0;
     $294 = ($$0396|0)==(31);
     $295 = $$0396 >>> 1;
     $296 = (25 - ($295))|0;
     $297 = $294 ? 0 : $296;
     $298 = $$2 << $297;
     $$0383 = $298;$$0384 = $293;
     while(1) {
      $299 = ((($$0384)) + 4|0);
      $300 = HEAP32[$299>>2]|0;
      $301 = $300 & -8;
      $302 = ($301|0)==($$2|0);
      if ($302) {
       label = 126;
       break;
      }
      $303 = $$0383 >>> 31;
      $304 = (((($$0384)) + 16|0) + ($303<<2)|0);
      $305 = $$0383 << 1;
      $306 = HEAP32[$304>>2]|0;
      $307 = ($306|0)==(0|0);
      if ($307) {
       label = 123;
       break;
      } else {
       $$0383 = $305;$$0384 = $306;
      }
     }
     if ((label|0) == 123) {
      $308 = HEAP32[(177396)>>2]|0;
      $309 = ($308>>>0)>($304>>>0);
      if ($309) {
       _abort();
       // unreachable;
      } else {
       HEAP32[$304>>2] = $$1;
       $310 = ((($$1)) + 24|0);
       HEAP32[$310>>2] = $$0384;
       $311 = ((($$1)) + 12|0);
       HEAP32[$311>>2] = $$1;
       $312 = ((($$1)) + 8|0);
       HEAP32[$312>>2] = $$1;
       break;
      }
     }
     else if ((label|0) == 126) {
      $313 = ((($$0384)) + 8|0);
      $314 = HEAP32[$313>>2]|0;
      $315 = HEAP32[(177396)>>2]|0;
      $316 = ($315>>>0)<=($$0384>>>0);
      $317 = ($315>>>0)<=($314>>>0);
      $318 = $317 & $316;
      if ($318) {
       $319 = ((($314)) + 12|0);
       HEAP32[$319>>2] = $$1;
       HEAP32[$313>>2] = $$1;
       $320 = ((($$1)) + 8|0);
       HEAP32[$320>>2] = $314;
       $321 = ((($$1)) + 12|0);
       HEAP32[$321>>2] = $$0384;
       $322 = ((($$1)) + 24|0);
       HEAP32[$322>>2] = 0;
       break;
      } else {
       _abort();
       // unreachable;
      }
     }
    }
   } while(0);
   $323 = HEAP32[(177412)>>2]|0;
   $324 = (($323) + -1)|0;
   HEAP32[(177412)>>2] = $324;
   $325 = ($324|0)==(0);
   if ($325) {
    $$0212$in$i = (177864);
    while(1) {
     $$0212$i = HEAP32[$$0212$in$i>>2]|0;
     $326 = ($$0212$i|0)==(0|0);
     $327 = ((($$0212$i)) + 8|0);
     if ($326) {
      break;
     } else {
      $$0212$in$i = $327;
     }
    }
    HEAP32[(177412)>>2] = -1;
   }
  }
 } while(0);
 $328 = HEAP32[(177824)>>2]|0;
 $329 = $328 & 2;
 $330 = ($329|0)==(0);
 if ($330) {
  return;
 }
 (___pthread_mutex_unlock((177828))|0);
 return;
}
function _sbrk(increment) {
    increment = increment|0;
    var oldDynamicTop = 0;
    var oldDynamicTopOnChange = 0;
    var newDynamicTop = 0;
    var totalMemory = 0;
    increment = ((increment + 15) & -16)|0;
    totalMemory = getTotalMemory()|0;

    // Perform a compare-and-swap loop to update the new dynamic top value. This is because
    // this function can becalled simultaneously in multiple threads.
    do {
      oldDynamicTop = Atomics_load(HEAP32, DYNAMICTOP_PTR>>2)|0;
      newDynamicTop = oldDynamicTop + increment | 0;
      // Asking to increase dynamic top to a too high value? In pthreads builds we cannot
      // enlarge memory, so this needs to fail.
      if (((increment|0) > 0 & (newDynamicTop|0) < (oldDynamicTop|0)) // Detect and fail if we would wrap around signed 32-bit int.
        | (newDynamicTop|0) < 0 // Also underflow, sbrk() should be able to be used to subtract.
        | (newDynamicTop|0) > (totalMemory|0)) {
        abortOnCannotGrowMemory()|0;
      }
      // Attempt to update the dynamic top to new value. Another thread may have beat this thread to the update,
      // in which case we will need to start over by iterating the loop body again.
      oldDynamicTopOnChange = Atomics_compareExchange(HEAP32, DYNAMICTOP_PTR>>2, oldDynamicTop|0, newDynamicTop|0)|0;
    } while((oldDynamicTopOnChange|0) != (oldDynamicTop|0));
    return oldDynamicTop|0;
}
function ___pthread_mutex_lock($0) {
 $0 = $0|0;
 var $$0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = HEAP32[$0>>2]|0;
 $2 = $1 & 15;
 $3 = ($2|0)==(0);
 if ($3) {
  $4 = ((($0)) + 4|0);
  $5 = (Atomics_compareExchange(HEAP32, $4>>2,0,16)|0);
  $6 = ($5|0)==(0);
  if ($6) {
   $$0 = 0;
   return ($$0|0);
  }
 }
 $7 = (___pthread_mutex_timedlock($0,0)|0);
 $$0 = $7;
 return ($$0|0);
}
function ___pthread_mutex_unlock($0) {
 $0 = $0|0;
 var $$0 = 0, $$045 = 0, $$pre = 0, $$pre$phiZ2D = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 var $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0;
 var $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = ((($0)) + 8|0);
 $2 = (Atomics_load(HEAP32,$1>>2)|0);
 $3 = HEAP32[$0>>2]|0;
 $4 = $3 & 15;
 $5 = $3 & 128;
 $6 = $5 ^ 128;
 $7 = ($4|0)==(0);
 if ($7) {
  $$pre = ((($0)) + 4|0);
  $$045 = 0;$$pre$phiZ2D = $$pre;
 } else {
  $8 = (_pthread_self()|0);
  $9 = ((($0)) + 4|0);
  $10 = (Atomics_load(HEAP32,$9>>2)|0);
  $11 = $10 & 2147483647;
  $12 = ((($8)) + 52|0);
  $13 = HEAP32[$12>>2]|0;
  $14 = ($11|0)==($13|0);
  if (!($14)) {
   $$0 = 1;
   return ($$0|0);
  }
  $15 = $3 & 3;
  $16 = ($15|0)==(1);
  if ($16) {
   $17 = ((($0)) + 20|0);
   $18 = HEAP32[$17>>2]|0;
   $19 = ($18|0)==(0);
   if (!($19)) {
    $20 = (($18) + -1)|0;
    HEAP32[$17>>2] = $20;
    $$0 = 0;
    return ($$0|0);
   }
  }
  $21 = ($6|0)==(0);
  $22 = ((($0)) + 16|0);
  if ($21) {
   $23 = ((($8)) + 176|0);
   Atomics_store(HEAP32,$23>>2,$22)|0;
   ___vm_lock();
  }
  $24 = ((($0)) + 12|0);
  $25 = HEAP32[$24>>2]|0;
  $26 = HEAP32[$22>>2]|0;
  Atomics_store(HEAP32,$25>>2,$26)|0;
  $27 = ((($8)) + 168|0);
  $28 = ($26|0)==($27|0);
  if ($28) {
   $$045 = $8;$$pre$phiZ2D = $9;
  } else {
   $29 = ((($26)) + -4|0);
   Atomics_store(HEAP32,$29>>2,$25)|0;
   $$045 = $8;$$pre$phiZ2D = $9;
  }
 }
 $30 = $3 & 8;
 $31 = ($30|0)!=(0);
 $32 = $31 ? 2147483647 : 0;
 while(1) {
  $33 = (Atomics_load(HEAP32, $$pre$phiZ2D>>2)|0);
  $34 = (Atomics_compareExchange(HEAP32, $$pre$phiZ2D>>2,$33,$32)|0);
  $35 = ($34|0)==($33|0);
  if ($35) {
   break;
  }
 }
 $36 = ($6|0)!=(0);
 $or$cond = $7 | $36;
 if (!($or$cond)) {
  $37 = ((($$045)) + 176|0);
  Atomics_store(HEAP32,$37>>2,0)|0;
  ___vm_unlock();
 }
 $38 = ($2|0)!=(0);
 $39 = ($33|0)<(0);
 $or$cond3 = $38 | $39;
 if (!($or$cond3)) {
  $$0 = 0;
  return ($$0|0);
 }
 (_emscripten_futex_wake(($$pre$phiZ2D|0),1)|0);
 $$0 = 0;
 return ($$0|0);
}
var Fetch = {
  attr_t_offset_requestMethod: 0,
  attr_t_offset_userData: 32,
  attr_t_offset_onsuccess: 36,
  attr_t_offset_onerror: 40,
  attr_t_offset_onprogress: 44,
  attr_t_offset_attributes: 48,
  attr_t_offset_timeoutMSecs: 52,
  attr_t_offset_withCredentials: 56,
  attr_t_offset_destinationPath: 60,
  attr_t_offset_userName: 64,
  attr_t_offset_password: 68,
  attr_t_offset_requestHeaders: 72,
  attr_t_offset_overriddenMimeType: 76,
  attr_t_offset_requestData: 80,
  attr_t_offset_requestDataSize: 84,

  fetch_t_offset_id: 0,
  fetch_t_offset_userData: 4,
  fetch_t_offset_url: 8,
  fetch_t_offset_data: 12,
  fetch_t_offset_numBytes: 16,
  fetch_t_offset_dataOffset: 24,
  fetch_t_offset_totalBytes: 32,
  fetch_t_offset_readyState: 40,
  fetch_t_offset_status: 42,
  fetch_t_offset_statusText: 44,
  fetch_t_offset___proxyState: 108,
  fetch_t_offset___attributes: 112,

  xhrs: [],
  // The web worker that runs proxied file I/O requests.
  worker: undefined,
  // Specifies an instance to the IndexedDB database. The database is opened
  // as a preload step before the Emscripten application starts.
  dbInstance: undefined,

  setu64: function(addr, val) {
    HEAPU32[addr >> 2] = val;
    HEAPU32[addr + 4 >> 2] = (val / 4294967296)|0;
  },

  openDatabase: function(dbname, dbversion, onsuccess, onerror) {
    try {

      console.log('fetch: indexedDB.open(dbname="' + dbname + '", dbversion="' + dbversion + '");');

      var openRequest = indexedDB.open(dbname, dbversion);
    } catch (e) { return onerror(e); }

    openRequest.onupgradeneeded = function(event) {

      console.log('fetch: IndexedDB upgrade needed. Clearing database.');

      var db = event.target.result;
      if (db.objectStoreNames.contains('FILES')) {
        db.deleteObjectStore('FILES');
      }
      db.createObjectStore('FILES');
    };
    openRequest.onsuccess = function(event) { onsuccess(event.target.result); };
    openRequest.onerror = function(error) { onerror(error); };
  },

  initFetchWorker: function() {
    var stackSize = 128*1024;
    var stack = allocate(stackSize>>2, "i32*", ALLOC_DYNAMIC);
    Fetch.worker.postMessage({cmd: 'init', TOTAL_MEMORY: TOTAL_MEMORY, DYNAMICTOP_PTR: DYNAMICTOP_PTR, STACKTOP: stack, STACK_MAX: stack + stackSize, queuePtr: _fetch_work_queue, buffer: HEAPU8.buffer});
  },

  staticInit: function() {



    var isMainThread = (typeof ENVIRONMENT_IS_FETCH_WORKER === 'undefined');


    var onsuccess = function(db) {

      console.log('fetch: IndexedDB successfully opened.');

      Fetch.dbInstance = db;







      if (typeof ENVIRONMENT_IS_FETCH_WORKER === 'undefined' || !ENVIRONMENT_IS_FETCH_WORKER) removeRunDependency('library_fetch_init');

    };
    var onerror = function() {

      console.error('fetch: IndexedDB open failed.');

      Fetch.dbInstance = false;







    };
    Fetch.openDatabase('emscripten_filesystem', 1, onsuccess, onerror);
    if (typeof ENVIRONMENT_IS_FETCH_WORKER === 'undefined' || !ENVIRONMENT_IS_FETCH_WORKER) addRunDependency('library_fetch_init');

  }
}

function __emscripten_fetch_delete_cached_data(db, fetch, onsuccess, onerror) {
  if (!db) {

    console.error('fetch: IndexedDB not available!');

    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var path = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  if (!path) path = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  var pathStr = Pointer_stringify(path);

  try {
    var transaction = db.transaction(['FILES'], 'readwrite');
    var packages = transaction.objectStore('FILES');
    var request = packages.delete(pathStr);
    request.onsuccess = function(event) {
      var value = event.target.result;

      console.log('fetch: Deleted file ' + pathStr + ' from IndexedDB');

      HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = 0;
      Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, 0);
      Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
      Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
      stringToUTF8("OK", fetch + Fetch.fetch_t_offset_statusText, 64);
      onsuccess(fetch, 0, value);
    };
    request.onerror = function(error) {

      console.error('fetch: Failed to delete file ' + pathStr + ' from IndexedDB! error: ' + error);

      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
      stringToUTF8("Not Found", fetch + Fetch.fetch_t_offset_statusText, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {

    console.error('fetch: Failed to load file ' + pathStr + ' from IndexedDB! Got exception ' + e);

    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_load_cached_data(db, fetch, onsuccess, onerror) {
  if (!db) {

    console.error('fetch: IndexedDB not available!');

    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var path = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  if (!path) path = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  var pathStr = Pointer_stringify(path);

  try {
    var transaction = db.transaction(['FILES'], 'readonly');
    var packages = transaction.objectStore('FILES');
    var getRequest = packages.get(pathStr);
    getRequest.onsuccess = function(event) {
      if (event.target.result) {
        var value = event.target.result;
        var len = value.byteLength || value.length;

        console.log('fetch: Loaded file ' + pathStr + ' from IndexedDB, length: ' + len);


        // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
        // freed when emscripten_fetch_close() is called.
        var ptr = _malloc(len);
        HEAPU8.set(new Uint8Array(value), ptr);
        HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = ptr;
        Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, len);
        Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
        Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, len);
        HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
        stringToUTF8("OK", fetch + Fetch.fetch_t_offset_statusText, 64);
        onsuccess(fetch, 0, value);
      } else {
        // Succeeded to load, but the load came back with the value of undefined, treat that as an error since we never store undefined in db.

        console.error('fetch: File ' + pathStr + ' not found in IndexedDB');

        HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
        stringToUTF8("Not Found", fetch + Fetch.fetch_t_offset_statusText, 64);
        onerror(fetch, 0, 'no data');
      }
    };
    getRequest.onerror = function(error) {

      console.error('fetch: Failed to load file ' + pathStr + ' from IndexedDB!');

      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
      stringToUTF8("Not Found", fetch + Fetch.fetch_t_offset_statusText, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {

    console.error('fetch: Failed to load file ' + pathStr + ' from IndexedDB! Got exception ' + e);

    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_cache_data(db, fetch, data, onsuccess, onerror) {
  if (!db) {

    console.error('fetch: IndexedDB not available!');

    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var destinationPath = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  if (!destinationPath) destinationPath = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  var destinationPathStr = Pointer_stringify(destinationPath);

  try {
    var transaction = db.transaction(['FILES'], 'readwrite');
    var packages = transaction.objectStore('FILES');
    var putRequest = packages.put(data, destinationPathStr);
    putRequest.onsuccess = function(event) {

      console.log('fetch: Stored file "' + destinationPathStr + '" to IndexedDB cache.');

      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
      stringToUTF8("OK", fetch + Fetch.fetch_t_offset_statusText, 64);
      onsuccess(fetch, 0, destinationPathStr);
    };
    putRequest.onerror = function(error) {

      console.error('fetch: Failed to store file "' + destinationPathStr + '" to IndexedDB cache!');

      // Most likely we got an error if IndexedDB is unwilling to store any more data for this page.
      // TODO: Can we identify and break down different IndexedDB-provided errors and convert those
      // to more HTTP status codes for more information?
      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 413; // Mimic XHR HTTP status code 413 "Payload Too Large"
      stringToUTF8("Payload Too Large", fetch + Fetch.fetch_t_offset_statusText, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {

      console.error('fetch: Failed to store file "' + destinationPathStr + '" to IndexedDB cache! Exception: ' + e);

    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_xhr(fetch, onsuccess, onerror, onprogress) {
  var url = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  if (!url) {

    console.error('fetch: XHR failed, no URL specified!');

    onerror(fetch, 0, 'no url specified!');
    return;
  }
  var url_ = Pointer_stringify(url);

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var requestMethod = Pointer_stringify(fetch_attr);
  if (!requestMethod) requestMethod = 'GET';
  var userData = HEAPU32[fetch_attr + Fetch.attr_t_offset_userData >> 2];
  var fetchAttributes = HEAPU32[fetch_attr + Fetch.attr_t_offset_attributes >> 2];
  var timeoutMsecs = HEAPU32[fetch_attr + Fetch.attr_t_offset_timeoutMSecs >> 2];
  var withCredentials = !!HEAPU32[fetch_attr + Fetch.attr_t_offset_withCredentials >> 2];
  var destinationPath = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  var userName = HEAPU32[fetch_attr + Fetch.attr_t_offset_userName >> 2];
  var password = HEAPU32[fetch_attr + Fetch.attr_t_offset_password >> 2];
  var requestHeaders = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestHeaders >> 2];
  var overriddenMimeType = HEAPU32[fetch_attr + Fetch.attr_t_offset_overriddenMimeType >> 2];
  var dataPtr = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestData >> 2];
  var dataLength = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestDataSize >> 2];

  var fetchAttrLoadToMemory = !!(fetchAttributes & 1/*EMSCRIPTEN_FETCH_LOAD_TO_MEMORY*/);
  var fetchAttrStreamData = !!(fetchAttributes & 2/*EMSCRIPTEN_FETCH_STREAM_DATA*/);
  var fetchAttrPersistFile = !!(fetchAttributes & 4/*EMSCRIPTEN_FETCH_PERSIST_FILE*/);
  var fetchAttrAppend = !!(fetchAttributes & 8/*EMSCRIPTEN_FETCH_APPEND*/);
  var fetchAttrReplace = !!(fetchAttributes & 16/*EMSCRIPTEN_FETCH_REPLACE*/);
  var fetchAttrNoDownload = !!(fetchAttributes & 32/*EMSCRIPTEN_FETCH_NO_DOWNLOAD*/);
  var fetchAttrSynchronous = !!(fetchAttributes & 64/*EMSCRIPTEN_FETCH_SYNCHRONOUS*/);
  var fetchAttrWaitable = !!(fetchAttributes & 128/*EMSCRIPTEN_FETCH_WAITABLE*/);

  var userNameStr = userName ? Pointer_stringify(userName) : undefined;
  var passwordStr = password ? Pointer_stringify(password) : undefined;
  var overriddenMimeTypeStr = overriddenMimeType ? Pointer_stringify(overriddenMimeType) : undefined;

  var xhr = new XMLHttpRequest();
  xhr.withCredentials = withCredentials;

  console.log('fetch: xhr.timeout: ' + xhr.timeout + ', xhr.withCredentials: ' + xhr.withCredentials);
  console.log('fetch: xhr.open(requestMethod="' + requestMethod + '", url: "' + url_ +'", userName: ' + userNameStr + ', password: ' + passwordStr + ');');

  xhr.open(requestMethod, url_, !fetchAttrSynchronous, userNameStr, passwordStr);
  if (!fetchAttrSynchronous) xhr.timeout = timeoutMsecs; // XHR timeout field is only accessible in async XHRs, and must be set after .open() but before .send().
  xhr.url_ = url_; // Save the url for debugging purposes (and for comparing to the responseURL that server side advertised)
  xhr.responseType = fetchAttrStreamData ? 'moz-chunked-arraybuffer' : 'arraybuffer';

  if (overriddenMimeType) {

    console.log('fetch: xhr.overrideMimeType("' + overriddenMimeTypeStr + '");');

    xhr.overrideMimeType(overriddenMimeTypeStr);
  }
  if (requestHeaders) {
    for(;;) {
      var key = HEAPU32[requestHeaders >> 2];
      if (!key) break;
      var value = HEAPU32[requestHeaders + 4 >> 2];
      if (!value) break;
      requestHeaders += 8;
      var keyStr = Pointer_stringify(key);
      var valueStr = Pointer_stringify(value);

      console.log('fetch: xhr.setRequestHeader("' + keyStr + '", "' + valueStr + '");');

      xhr.setRequestHeader(keyStr, valueStr);
    }
  }
  Fetch.xhrs.push(xhr);
  var id = Fetch.xhrs.length;
  HEAPU32[fetch + Fetch.fetch_t_offset_id >> 2] = id;
  var data = (dataPtr && dataLength) ? HEAPU8.slice(dataPtr, dataPtr + dataLength) : null;
  // TODO: Support specifying custom headers to the request.

  xhr.onload = function(e) {
    var len = xhr.response ? xhr.response.byteLength : 0;
    var ptr = 0;
    var ptrLen = 0;
    if (fetchAttrLoadToMemory && !fetchAttrStreamData) {
      ptrLen = len;

      console.log('fetch: allocating ' + ptrLen + ' bytes in Emscripten heap for xhr data');

      // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
      // freed when emscripten_fetch_close() is called.
      ptr = _malloc(ptrLen);
      HEAPU8.set(new Uint8Array(xhr.response), ptr);
    }
    HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = ptr;
    Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, ptrLen);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
    if (len) {
      // If the final XHR.onload handler receives the bytedata to compute total length, report that,
      // otherwise don't write anything out here, which will retain the latest byte size reported in
      // the most recent XHR.onprogress handler.
      Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, len);
    }
    HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = xhr.readyState;
    if (xhr.readyState === 4 && xhr.status === 0) {
      if (len > 0) xhr.status = 200; // If loading files from a source that does not give HTTP status code, assume success if we got data bytes.
      else xhr.status = 404; // Conversely, no data bytes is 404.
    }
    HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = xhr.status;
    if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + Fetch.fetch_t_offset_statusText, 64);
    if (xhr.status == 200) {

      console.log('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" succeeded with status 200');

      if (onsuccess) onsuccess(fetch, xhr, e);
    } else {

      console.error('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" failed with status ' + xhr.status);

      if (onerror) onerror(fetch, xhr, e);
    }
  }
  xhr.onerror = function(e) {
    var status = xhr.status; // XXX TODO: Overwriting xhr.status doesn't work here, so don't override anywhere else either.
    if (xhr.readyState == 4 && status == 0) status = 404; // If no error recorded, pretend it was 404 Not Found.

    console.error('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" finished with error, readyState ' + xhr.readyState + ' and status ' + status);

    HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = 0;
    Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, 0);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, 0);
    HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = xhr.readyState;
    HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = status;
    if (onerror) onerror(fetch, xhr, e);
  }
  xhr.ontimeout = function(e) {

    console.error('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" timed out, readyState ' + xhr.readyState + ' and status ' + xhr.status);

    if (onerror) onerror(fetch, xhr, e);
  }
  xhr.onprogress = function(e) {
    var ptrLen = (fetchAttrLoadToMemory && fetchAttrStreamData && xhr.response) ? xhr.response.byteLength : 0;
    var ptr = 0;
    if (fetchAttrLoadToMemory && fetchAttrStreamData) {

      console.log('fetch: allocating ' + ptrLen + ' bytes in Emscripten heap for xhr data');

      // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
      // freed when emscripten_fetch_close() is called.
      ptr = _malloc(ptrLen);
      HEAPU8.set(new Uint8Array(xhr.response), ptr);
    }
    HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = ptr;
    Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, ptrLen);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, e.loaded - ptrLen);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, e.total);
    HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = xhr.readyState;
    if (xhr.readyState >= 3 && xhr.status === 0 && e.loaded > 0) xhr.status = 200; // If loading files from a source that does not give HTTP status code, assume success if we get data bytes
    HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = xhr.status;
    if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + Fetch.fetch_t_offset_statusText, 64);
    if (onprogress) onprogress(fetch, xhr, e);
  }

  console.log('fetch: xhr.send(data=' + data + ')');

  try {
    xhr.send(data);
  } catch(e) {

    console.error('fetch: xhr failed with exception: ' + e);

    if (onerror) onerror(fetch, xhr, e);
  }
}

function emscripten_start_fetch(fetch, successcb, errorcb, progresscb) {
  if (typeof Module !== 'undefined') Module['noExitRuntime'] = true; // If we are the main Emscripten runtime, we should not be closing down.

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var requestMethod = Pointer_stringify(fetch_attr);
  var onsuccess = HEAPU32[fetch_attr + Fetch.attr_t_offset_onsuccess >> 2];
  var onerror = HEAPU32[fetch_attr + Fetch.attr_t_offset_onerror >> 2];
  var onprogress = HEAPU32[fetch_attr + Fetch.attr_t_offset_onprogress >> 2];
  var fetchAttributes = HEAPU32[fetch_attr + Fetch.attr_t_offset_attributes >> 2];
  var fetchAttrLoadToMemory = !!(fetchAttributes & 1/*EMSCRIPTEN_FETCH_LOAD_TO_MEMORY*/);
  var fetchAttrStreamData = !!(fetchAttributes & 2/*EMSCRIPTEN_FETCH_STREAM_DATA*/);
  var fetchAttrPersistFile = !!(fetchAttributes & 4/*EMSCRIPTEN_FETCH_PERSIST_FILE*/);
  var fetchAttrAppend = !!(fetchAttributes & 8/*EMSCRIPTEN_FETCH_APPEND*/);
  var fetchAttrReplace = !!(fetchAttributes & 16/*EMSCRIPTEN_FETCH_REPLACE*/);
  var fetchAttrNoDownload = !!(fetchAttributes & 32/*EMSCRIPTEN_FETCH_NO_DOWNLOAD*/);

  var reportSuccess = function(fetch, xhr, e) {

    console.log('fetch: operation success. e: ' + e);

    if (onsuccess && typeof dynCall === 'function') Module['dynCall_vi'](onsuccess, fetch);
    else if (successcb) successcb(fetch);
  };

  var cacheResultAndReportSuccess = function(fetch, xhr, e) {

    console.log('fetch: operation success. Caching result.. e: ' + e);

    var storeSuccess = function(fetch, xhr, e) {

      console.log('fetch: IndexedDB store succeeded.');

      if (onsuccess && typeof dynCall === 'function') Module['dynCall_vi'](onsuccess, fetch);
      else if (successcb) successcb(fetch);
    };
    var storeError = function(fetch, xhr, e) {

      console.error('fetch: IndexedDB store failed.');

      if (onsuccess && typeof dynCall === 'function') Module['dynCall_vi'](onsuccess, fetch);
      else if (successcb) successcb(fetch);
    };
    __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, xhr.response, storeSuccess, storeError);
  };

  var reportProgress = function(fetch, xhr, e) {
    if (onprogress && typeof dynCall === 'function') Module['dynCall_vi'](onprogress, fetch);
    else if (progresscb) progresscb(fetch);
  };

  var reportError = function(fetch, xhr, e) {

    console.error('fetch: operation failed: ' + e);

    if (onerror && typeof dynCall === 'function') Module['dynCall_vi'](onerror, fetch);
    else if (errorcb) errorcb(fetch);
  };

  var performUncachedXhr = function(fetch, xhr, e) {

    console.error('fetch: starting (uncached) XHR: ' + e);

    __emscripten_fetch_xhr(fetch, reportSuccess, reportError, reportProgress);
  };

  var performCachedXhr = function(fetch, xhr, e) {

    console.error('fetch: starting (cached) XHR: ' + e);

    __emscripten_fetch_xhr(fetch, cacheResultAndReportSuccess, reportError, reportProgress);
  };

  // Should we try IndexedDB first?
  if (!fetchAttrReplace || requestMethod === 'EM_IDB_STORE' || requestMethod === 'EM_IDB_DELETE') {
    if (!Fetch.dbInstance) {

      console.error('fetch: failed to read IndexedDB! Database is not open.');

      reportError(fetch, 0, 'IndexedDB is not open');
      return 0; // todo: free
    }

    if (requestMethod === 'EM_IDB_STORE') {
      var dataPtr = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestData >> 2];
      var dataLength = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestDataSize >> 2];
      var data = HEAPU8.slice(dataPtr, dataPtr + dataLength); // TODO(?): Here we perform a clone of the data, because storing shared typed arrays to IndexedDB does not seem to be allowed.
      __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, data, reportSuccess, reportError);
    } else if (requestMethod === 'EM_IDB_DELETE') {
      __emscripten_fetch_delete_cached_data(Fetch.dbInstance, fetch, reportSuccess, reportError);
    } else if (fetchAttrNoDownload) {
      __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, reportError);
    } else if (fetchAttrPersistFile) {
      __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, performCachedXhr);
    } else {
      __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, performUncachedXhr);
    }
  } else if (!fetchAttrNoDownload) {
    if (fetchAttrPersistFile) {
      __emscripten_fetch_xhr(fetch, cacheResultAndReportSuccess, reportError, reportProgress);
    } else {
      __emscripten_fetch_xhr(fetch, reportSuccess, reportError, reportProgress);
    }
  } else {

    console.error('fetch: Invalid combination of flags passed.');

    return 0; // todo: free
  }
  return fetch;
}

if (typeof Atomics === 'undefined') {
  // Polyfill singlethreaded atomics ops from http://lars-t-hansen.github.io/ecmascript_sharedmem/shmem.html#Atomics.add
  // No thread-safety needed since we don't have multithreading support.
  Atomics = {};
  Atomics['add'] = function(t, i, v) { var w = t[i]; t[i] += v; return w; }
  Atomics['and'] = function(t, i, v) { var w = t[i]; t[i] &= v; return w; }
  Atomics['compareExchange'] = function(t, i, e, r) { var w = t[i]; if (w == e) t[i] = r; return w; }
  Atomics['exchange'] = function(t, i, v) { var w = t[i]; t[i] = v; return w; }
  Atomics['wait'] = function(t, i, v, o) { if (t[i] != v) return 'not-equal'; else return 'timed-out'; }
  Atomics['wake'] = function(t, i, c) { return 0; }
  Atomics['wakeOrRequeue'] = function(t, i1, c, i2, v) { return 0; }
  Atomics['isLockFree'] = function(s) { return true; }
  Atomics['load'] = function(t, i) { return t[i]; }
  Atomics['or'] = function(t, i, v) { var w = t[i]; t[i] |= v; return w; }
  Atomics['store'] = function(t, i, v) { t[i] = v; return v; }
  Atomics['sub'] = function(t, i, v) { var w = t[i]; t[i] -= v; return w; }
  Atomics['xor'] = function(t, i, v) { var w = t[i]; t[i] ^= v; return w; }
}

var Atomics_add = Atomics.add;
var Atomics_and = Atomics.and;
var Atomics_compareExchange = Atomics.compareExchange;
var Atomics_exchange = Atomics.exchange;
var Atomics_wait = Atomics.wait;
var Atomics_wake = Atomics.wake;
var Atomics_wakeOrRequeue = Atomics.wakeOrRequeue;
var Atomics_isLockFree = Atomics.isLockFree;
var Atomics_load = Atomics.load;
var Atomics_or = Atomics.or;
var Atomics_store = Atomics.store;
var Atomics_sub = Atomics.sub;
var Atomics_xor = Atomics.xor;

var ENVIRONMENT_IS_FETCH_WORKER = true;
var ENVIRONMENT_IS_WORKER = true;
var ENVIRONMENT_IS_PTHREAD = true;
var __pthread_is_main_runtime_thread=0;
var DYNAMICTOP_PTR = 0;
var TOTAL_MEMORY = 0;
function enlargeMemory() {
  abort('Cannot enlarge memory arrays, since compiling with pthreads support enabled (-s USE_PTHREADS=1).');
}
var nan = NaN;
var inf = Infinity;

function _emscripten_asm_const_v() {}

function assert(condition) {
  if (!condition) console.error('assert failure!');
}

/// TODO: DO SOMETHING ABOUT ME.
function Pointer_stringify(ptr, /* optional */ length) {
  if (length === 0 || !ptr) return "";
  // TODO: use TextDecoder
  // Find the length, and check for UTF while doing so
  var hasUtf = 0;
  var t;
  var i = 0;
  while (1) {
    t = HEAPU8[(((ptr)+(i))>>0)];
    hasUtf |= t;
    if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;

  var ret = "";

  if (hasUtf < 128) {
    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
      ret = ret ? ret + curr : curr;
      ptr += MAX_CHUNK;
      length -= MAX_CHUNK;
    }
    return ret;
  }
  return Module['UTF8ToString'](ptr);
}

Fetch.staticInit();

var queuePtr = 0;
var buffer = null;
var STACKTOP = 0;
var STACK_MAX = 0;
var HEAP8 = null;
var HEAPU8 = null;
var HEAP16 = null;
var HEAPU16 = null;
var HEAP32 = null;
var HEAPU32 = null;

function processWorkQueue() {
  if (!queuePtr) return;
  var numQueuedItems = Atomics_load(HEAPU32, queuePtr + 4 >> 2);
  if (numQueuedItems == 0) return;

  var queuedOperations = Atomics_load(HEAPU32, queuePtr >> 2);
  var queueSize = Atomics_load(HEAPU32, queuePtr + 8 >> 2);
  for(var i = 0; i < numQueuedItems; ++i) {
    var fetch = Atomics_load(HEAPU32, (queuedOperations >> 2)+i);
    function successcb(fetch) {
      Atomics.compareExchange(HEAPU32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1, 2);
      Atomics.wake(HEAP32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1);
    }
    function errorcb(fetch) {
      Atomics.compareExchange(HEAPU32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1, 2);
      Atomics.wake(HEAP32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1);
    }
    function progresscb(fetch) {
    }
    try {
      emscripten_start_fetch(fetch, successcb, errorcb, progresscb);
    } catch(e) {
      console.error(e);
    }
    /*
    if (interval != undefined) {
      clearInterval(interval);
      interval = undefined;
    }
    */
  }
  Atomics_store(HEAPU32, queuePtr + 4 >> 2, 0);
}

interval = 0;
this.onmessage = function(e) {
  if (e.data.cmd == 'init') {
    queuePtr = e.data.queuePtr;
    buffer = e.data.buffer;
    STACKTOP = e.data.STACKTOP;
    STACK_MAX = e.data.STACK_MAX;
    DYNAMICTOP_PTR = e.data.DYNAMICTOP_PTR;
    TOTAL_MEMORY = e.data.TOTAL_MEMORY;
    HEAP8 = new Int8Array(buffer);
    HEAPU8 = new Uint8Array(buffer);
    HEAP16 = new Int16Array(buffer);
    HEAPU16 = new Uint16Array(buffer);
    HEAP32 = new Int32Array(buffer);
    HEAPU32 = new Uint32Array(buffer);
    interval = setInterval(processWorkQueue, 100);
  }
}
